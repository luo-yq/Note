ActiveMq的安装,RabbitMq,RocketMq,Kafka,Redis 都可实习消息队列

特点：
RocketMq 同队列不支持优先级，优先级不同的信息只能通过优先级不同的topic来弥补，topic的数量应尽可能的少
RocketMq 同队列的消息可以保证被顺序消费
RocketMq 消息至少消费一次





ActiveMq的安装部署


RabbitMq的安装部署


RocketMq的安装部署


Kafka的安装部署


Redis的安装部署





消息中间件通常采用的几种持久化方式：

持久化到数据库，例如Mysql。
持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。
文件记录形式持久化，例如Kafka，RocketMQ
对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify
(1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，(4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。
JMS与CORBA Notification规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个消息中间件的性能。

RocketMQ充分利用Linux文件系统内存cache来提高性能。



影响消息可靠性的几种情况：

Broker正常关闭
Broker异常Crash
OS Crash
机器掉电，但是能立即恢复供电情况。
机器无法开机（可能是cpu、主板、内存等关键设备损坏）
磁盘设备损坏。
(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。

(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。

RocketMQ从3.0版本开始支持同步双写。

