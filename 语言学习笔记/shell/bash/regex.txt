查找文本
用到的关键字 grep，最简单的用法就是使用固定字符串。

比如使用 who 命令查找当前多少人登陆系统

who |grep syx，就可以查看名字叫 syx 的用户登录于何处。
grep 的语法:
grep [options pattern-spec [files...]
用途: 显示匹配一个或者多个模式的文本行。时常为作为管道的第一步，以便对匹配的数据进一步处理。

主要选项
-i: 模式匹配时忽略大小写
-V: 显示不匹配的行
-l: 列出匹配模式的文件名称，而不是打印匹配的行
-n: 列出检索目标所在的行号
-c: 统计匹配的行总数，不显示航信息
行为模式
读取命令行上致命的每个文件，发现匹配查找迷失的行时，将它显示出来，当指名多个文件时,grep 会在每一行前面加上文件名与一个冒号。

grep: 最常用，可以检索目标 (一个活多个单词或正则表达式)。
fgrep: 不能使用正则表达式，可以检索多个目标，等同于 grep -f
egrep: 支持丰富的正则表达式，而且支持多目标检索，等同于 grep -e。
一般情况下没有使用 fgrep 的，我们也不建议使用。

说起文本检索就不得不提到正则表达式，正则表达式十一中表示方法，可以查找匹配特定准则的文本。例如，查找以”a” 字母开头的文本。茨表示法可以写一个表达式，选定或匹配多个数据字符串。

从根本上来看，正则表达式是由两个基本组成部分所建立：一般字符与特殊字符。一般字符指的是任何没有特殊意义的字符。在某些情况下，特殊特殊字符也可以视为一般字符。特殊字符称为元字符（metacharacter）。

BRE: 基本正则表达式（Basic Regular Expression）
ERE: 扩展的正则表达式（Extended Regular Expression）
先来看一些简单的匹配返利

tolstoy: 匹配一行上任意位置的 7 个字母:tolstoy
^tolstoy: 7 个字母 tolstoy，出现在一行的开头
tolstoy$: 出现在一行的结尾
^tolstoy$: 正好包含这 7 个字母的一行，没有其他的任何字符。
[tT]olstoy: 在一行的任意位居中，含有 Tolstoy 或者 tolstoy
tol.toy: 在一行的任意位居中，含有 tol 这三个字母，加上一个特殊字符，在接着 toy 这三个字母
tol.*toy: 在一行的任意位居中，含有 tol 这三个字母，加上任意的 0 或者多个字符，再继续 toy 这三个字母 (例如:toltoy,tolstoy,tolWHOtoy 都是满足要求的)。
shell 中的通配符: *: 代表 0 个或者多个任意字符 ?: 代表一定有一个的任意字符 []: 代表一定有一个在括号内的字符 (非任意字符)。例如 [abcd] 代表一定有一个字符，可能是 abcd 这四个选项的任意一个。 [-]: 若邮件韩在括号内时，代表在编码顺序内的所有自负。例如:[0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的。 [^]: 若括号内的第一个字符为指数字符 (^)，那表示反向选择，例如:[^abc] 代表一定有一个字符，只要是非 abc 的其他字符就可以。

shell 中的特殊字符
#: 注释字符
\: 将特殊字符或者通配符还原成一般字符
|: 管道符，分割两个管线命令的界定
;: 连续命令下达分隔符
~: 用户的家目录
$: 放在变量前面，正确使用变量
&: 工作控制，将命令编程背景下工作
!: 非 (!) 的意思，逻辑运算符
,>>: 输出重定向，分别是覆盖和追加
<,<<: 输入重定向
‘’: 单引号，不具有变量置换的功能
“”: 双引号，具有变量置换的功能
(): 在中间的为子 shell 的起始与结束
{]: 在中间为命令块的组合
shell 中正则表达式的控制字符
^: 匹配行首位置
$: 匹配行尾位置
.: 匹配任意祖父
: 对 之前的匹配整体或字符匹配任意次 (包括 0 次)
\?: 对 \? 之前的匹配整体或字符匹配 0 次或 1 次
{n}: 对 \ { 之前的匹配整体或字符匹配 n 次
{m,}: 对 \ { 之前的匹配整体或字符匹配至少 m 次
{m,n}: 对 \ { 之前的匹配整体或字符匹配 m 到 n 次
[abcdef]: 对单字符而言匹配 [] 中的字符
[a-z]; 对单字符而言，匹配任意一个小写字母
基本正则表达式
匹配单个字符

匹配一般字符: 一般字符是指无特殊含义的字符，包括所有文本和数字字符，绝大多数的空白字符以及标点符号字符，因此，正则 a，匹配 a。
如果相匹配 ，因为 是特殊字符，所以需要用 \ 转义，正则 *，匹配 *。
(点号) 字符意即” 任意字符”，例如 a.c 匹配于 abc,aac。
使用方括号表达式。例如 x[abcdefg]z，可以匹配 xaz,xbz，等，方括号里如果存在 (^)，表示取反的意思，就是说不匹配列表里的任意字符。
[0123456789] 表示所数字，但是这样写太麻烦，我们可以用 [0-9] 来表示,[abcdefg] 同样可以用 [a-g]

单个表达式匹配多字符
最简单的办法就是把它们一一列出来: 正则 abc 匹配于 abc。虽然 (.)meta 字符与方括号表达式都提供了依次匹配一个字符的很好方式，单正则真正强大而有力地功能是修饰符 meta 字符的使用上。最常用的修饰符是 ()，表示匹配 0 个或多个前面的单个字符。因此 abc 表示” 匹配一个 a,0 个或多个 b 字符以及 a 空 c”。这个正则匹配的有 ac,abc,abbcabbbbc。匹配 0 或多个，不表示匹配其他的某一个。例如正则 ab*c，文本 aQc 是不匹配的。但是 ac 是匹配的。

(*) 修饰符虽然好用，但是他没有限制，如要只要指定次数，使用一个复杂的方括号表达式虽然也能指定次数，但是太过麻烦。我们就引入了区间表达式。所谓的区间表达式有三种变化
{n} 前置正则表达式所得结果重现 n 次
{n,} 前置正则表达式所得结果至少出现 n 次
{n,m} 出现 n 到 m 次
例如我们想要表达” 重现 5 个 a” =>a{5},” 重现 10 到 42 个 q”=>q{10,42};

文本匹配锚点
两个 meta 字符是脱节符号 (^)，与货币字符 (&)，他们叫做锚点，因为其用途在限制正则表达式匹配时，针对要被匹配字符的开始或者结尾处进行匹配,假定有一串字符串:abcABCdefDEF

正则表达式锚点的范例

模式	是否匹配	理由
ABC	是	居中的 4,5,6 字符匹配
^ABC	否	起始处不是 ABC
def$	是	结尾处不是 def
[[:upper:]]{3}	是	居中的大写 ABC 匹配
[[:upper:]]{3}$	是	结尾的大写 DEF 匹配
^[[:alpha:]]{3}	是	起始处的 abc 匹配
^ 和 $ 当然能同时使用，这种情况将括起来的正则表达式匹配整个字符串 (或行)。有时 ^$ 这样简易的正则很好用，可以用来匹配空的字符串或行列。例如加上 grep -v 选项用来显示所有不匹配模式的行们使用上面的做法，便能过滤掉文件里的空号。 ^$ 尽在起始与结尾具有特殊用处。例如 ab^cd 里的 ^ 表示的就是自身 (^)。

BRE 运算符哟普先机，由高到低
[..] [==] [::] 用于字符拍的方括号符号
\metacharacter 转移的 meta 字符
[] 方括号表达式
{} 子表达式
{} 前置单个字符重现的正则表达式
无符号 连续
^$ 锚点



扩展正则表达式 (ERE)
拥有笔记本正则表达式更多的功能。BRE 与 ERE 在大多数的 meta 字符与功能应用上几乎是完全一致，单 ERE 理由写 meta 字符看起来与 BRE 类似，却具有完全不同的类型。

扩展正则表达式与基础正则表达式的唯一区别在于：? + () {} 这几个字符。基础正则表达式中，如果你想? + () {} 表示特殊含义，你需要将他们转义。而扩展正则表达式中，如果你想? + () {} 不表示特殊含义，你需要将他们转义。转义符号，都是一样的，\ 符号。

所谓特殊含义，就是正则表达式中的含义。非特殊含义，就是这个符号本身。

例如

[root@shellcn.net ~#] echo aaa|grep 'a?';[root@shellcn.net ~#] echo aaa|grep 'a\?';aaa#egrep 使用的是扩展正则表达式
[root@shellcn.net ~#] echo aaa|egrep 'a?';aaa[root@shellcn.net ~#] echo aaa|egrep 'a\?';
可见，扩展正则表达式与基础正则表达式的区别，就是它们加不加转义符号，代表的意思刚好相反。

ERE 历史没有后向引用的。圆括号在 ERE 里具有特殊含义，但和 BRE 里使用的又有所不同。在 ERE 里，\ ( 与 \ ) 匹配的是字面上的左括号与右括号。

匹配单个表达式与多个正则表达式
ERE 在匹配多字符这方面，与 BRE 有明显的不同，不过在 (*) 的处理上和 BRE 是相同的。

注意:

有一个例外，* 作为 ERE 的第一个字符是” 未定义的”，而在 BRE 中它是指” 符合字面的”。
一般情况下使用 grep 控制 BRE，使用 egrep 控制 ERE。
使用 ERE 匹配我们之前介绍过的离子” 要刚好重现 5 个 a” 以及” 重现 10 个至 42 个 q”，写法分别为:a{5}，q{10,42}。而 {与 } 则可以匹配字面上的花括号。当在 ERE 里 {找不到匹配} 时，POSIX 特意保留其含义为” 未定义状态”。
ERE 另有两个 meta 字符，可更细腻的处理匹配控制:

? 匹配于 0 个或一个前置正则表达式
+ 匹配于一个或多个前置正则表达式
可以把? 想象成是” 可选用的”，也就是说，匹配前置正则表达式的文本，要么出现，要么没出现。例如: 与 ab?c 匹配的有 ac 与 abc，就这两者 ! (与 ab*c 相较之下，后者匹配于中间有人一个 b)。

+ 字符在概念上与 *meta 字符类似，不过前置正则表达式要匹配的文本在这里至少得出现一次。例如 ab+c 匹配于 abc,abbc,abbbc，但是不匹配于 ac。ab+c 的正则表达式等价于 abbc; 无论如何，当前值正则表达式很复杂时，使用 + 可以少打一点字，这就减少了打错字的几率。

交替
方括号运算符一宇表示” 匹配于次祖父，或其他字符，或...”，但不能指定” 匹配于这个序列，或其他序列”。要达到后者的目的，可以使用管道运算符 (|)。例如 read | write 匹配于 read 与 write 两者,fast|slow 匹配于 fast 与 slow。| 字符是 ERE 运算符;i 优先级最低的。

分组
基本正则表达式中支持分组，而在扩展正则表达式中，分组的功能更加强大，也可以说才是真正的分组，用法如下：

()：分组，后面可以使用 \1 \2 \3... 引用前面的分组，除了方便后面引用外，分组还非常方便的可以使用上述次数匹配方法进行匹配具有相同条件的数据。

如：grep '^(barlow).*\1' /etc/passwd 搜索 /etc/passwd 中以 barlow 开头，而后面还存在 barlow 的行。

在 BRE 中，我们使用一些 meta 字符修饰前置字符，匹配重复的情况。但是这样的操作仅仅针对单个字符。在 ERE 中，分组功能能够计 meta 字符修饰前置字符串。一个针对字符，一个针对字符串。

在 ERE 里，我么已经提到运算符是被应用到” 前置的正则表达式”。这是因为有圆方括号 ({...}) 提供分组功能，让接下来的运算符可以应用。例如 (why)+ 匹配于一个或连续重复的多个 why。再例如:[Tt]he (CPU|computer) is 指的是: 在 the(The) 与 is 之间，含有 CPU 或 computer 的句子。特别注意: 圆括号里的是 meta 字符，而非要匹配的输入文本。由此看出用到交替的时候，分组特别有用。

例如 (read|write)+ 指的是: 有一个或重现多个 read，或者一个或重现多个 write.(read|write)+ 所指的字符串中间，不允许有空白。当将交替操作结合 ^ 与 $ 锚点字符使用时，分组就非常好用了。由于 | 为所有运算符中优先级最低的，因此正则表达式 ^abcd|efgh$ 意思是” 匹配字符串的起始处是否具有 a b c d 或者字符串结尾是否具有 e f g h”(表示查找字符)，这和 ^(abcd)|(efgh)$ 不一样，后者的意思是” 找一个正好是 abcd 或正好是 efgh 的字符串”

停驻文本匹配 (锚点)
“^” 与”$” 在 ERE 和 BRE 表示的含义是相同的，需要注意的是他们在方括号表达式中将会失去他们的特殊意义；
组合使用，例如 this is ^(one|two)$ 匹配 one 或者 two。在 ERE 里，^ 和 $ 永远是 meta 字符。所以，像 ab^cd 与 ef$gh 这样的正则表达式仍然是有效的，只是无法匹配到任何东西，因为 ^ 前面有其他的字符串，$ 后面也有字符串，失去了他们的特殊含义。

ERE 运算符的优先级
[..]  [= =]  [:  :] 用于字符对应的方括号符号
\metacharacter 转移的 meta 字符
[] 方括号表达式 
() 分组
*  +  ?  {} 重复潜质的正则表达式
无符号 (no symbol) 连续字符
^    $ 锚点
| 交替
正则表达式的扩展
最常见的扩展为 \< 与 \> 运算符, 分别匹配” 单词 (word)” 的开头与结尾, 单词是由字母, 数字及下划线组成的。我们称这类字符为单词组成。

例如：\<chop 匹配于 use chopsticks，但是 eat a lambchop 则不匹配；同样的 chop>\ 匹配与第二个字符串，第一个则不匹配。特别注意：\<chop>\ 的表达式下，两个字符串都不匹配。

额外的 GNU 正则运算符
\w 匹配任何单词组成字符
\W 匹配任何非单词组成字符
\<\> 匹配单词的起始和结尾
\b 匹配单的起始或结尾处所找到的空字符串 / 这是 \< 与 >\ 运算符的结合. 注意: 由于 awk 使用 \b 表示后退运算符, 因此 GNU awk(gawk) 使用 \y 表示此功能。
\B 匹配两个单词组成字符之间的空字符串
\’ \ ` 分别匹配 emacs 缓冲区的开始与结尾.GNU 程序 (wmacs) 通常将他们是位 ^ 和 $ 同义。
例子：'<!-\?[^-]\+'#< 后面是 ! 然后是 0～1 个-，最后是一个非-字符。


