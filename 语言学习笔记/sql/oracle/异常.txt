
study
异常

PL/SQL 的异常(预定义异常)
异常名称                                      ORACLE错误             说明
CURSOR_ALREADY_OPEN                    ORA-6511          试图打开一个已打开的光标
DUP_VAL_ON_INDEX                          ORA-0001          试图破坏一个唯一性限制
INVALID_CURSOR                               ORA-1001          试图使用一个无效的光标
INVALID_NUMBER                               ORA-1722          试图对非数字值进行数字操作
LOGIN_DENIED                                  ORA-1017          无效的用户名或者口令
NO_DATA_FOUND                               ORA-1403          查询未找到数据 
NOT_LOGGED_ON                              ORA-1012          还未连接就试图数据库操作
PROGRAM_ERROR                              ORA-6501          内部错误
ROWTYPE_MISMATCH                         ORA-6504          主变量和光标的类型不兼容
STORAGE_ERROR                               ORA-6500          内部错误
TIMEOUT_ON_RESOURCE                   ORA-0051          发生超时
TOO_MANY_ROWS                             ORA-1422          SELECT INTD命令返回的多行
TRANSACTION_BACKED_OUT              ORA-006           由于死锁提交被退回
VALUE_ERROR                                   ORA-6502          转换或者裁剪错误
ZERO_DIVIDE                                    ORA-1476          试图被零除

Oracle异常总结
 
Oracle异常处理异常处理是考验一个应用程序健壮性的最好方式，开发人员必须考虑程序中可能出现的各种错误，并进行相应的处理。
Oracle中异常分为预定义异常，非预定义异常和自定义异常三种。
一 预定义异常预定义异常是指由PL/SQL所提供的系统异常。当PL/SQL应用程序违反了Oracle规则或出现其它系统限制的情况时，将会隐含地触发一个内部异常。
以下是PL/SQL为我们预定义的异常(经常更新中)：
1 CURSOR_ALREADY_OPEN该异常触发ORA-06511错误。
当程序中的一个游标已经执行了打开操作，如果开发人员试图再一次打开这个已经打开的游标时，将触发该异常。
示例：
DECLARE
CURSOR test_cursor IS
SELECT SYSDATE FROM dual;
BEGIN
OPEN test_cursor;
FOR test_cursor2 IN test_cursor LOOP
dbms_output.put_line(test_cursor2.SYSDATE);
END LOOP;
EXCEPTION
WHEN cursor_already_open THEN
dbms_output.put_line('游标已经打开，不能再次对游标执行打开操作。');
END;
/
2 INCALID_CURSOR该异常触发ORA-01001错误。
当试图对一个尚未打开的游标执行任何操作，如打开该非法的游标执行赋值操作，或者关闭未打开的游标时，将触发该异常。
示例：
DECLARE
CURSOR test_cursor IS
SELECT SYSDATE FROM dual;
test_time DATE;
BEGIN
--OPEN test_cursor;
FETCH test_cursor
INTO test_time;
dbms_output.put_line('当前时间为: ' || test_time);
CLOSE test_cursor;
EXCEPTION
WHEN invalid_cursor THEN
dbms_output.put_line('请检查游标是否已经打开.');
END;
/
3 NO_DA
TA_FOUND该异常触发ORA-01403错误。
当读取一个游标进行赋值操作(SELECT INTO操作)时，如果未返回任何行，将触发该异常。
示例：
DECLARE
test_owner DATE;
BEGIN
SELECT t.owner INTO test_owner FROM all_tables t WHERE t.table_name = 'test';
dbms_output.put_line(test_owner);
EXCEPTION
WHEN NO_DATA_FOUND THEN
dbms_output.put_line('No value.');
END;
/
4 TOO_MANY_ROWS该异常触发ORA-01422错误。
上面是没有返回记录，这里是返回对条记录的时候会触发该异常。
示例：
DECLARE
test_records dba_tables%ROWTYPE;
BEGIN
select * INTO test_records from dba_tables where owner='APPS' AND ROWNUM < 3;
dbms_output.put_line(test_records.table_name);
EXCEPTION
WHEN too_many_rows THEN
dbms_output.put_line('Too many values.');
END;
/
5 VALUE_ERROR该异常触发ORA-06502错误。
当在PL/SQL程序中执行赋值操作时，如果右边值的长度大于左边变量的长度，将触发该异常。
示例：
DECLARE
v_test VARCHAR2(1);
BEGIN
SELECT 'WHAT' INTO v_test FROM dual;
dbms_output.put_line(v_test);
EXCEPTION
WHEN value_error THEN
dbms_output.put_line('变量的长度不够.');
END;
/
6 DUP_VAL_ON_INDEX该异常触发ORA-00001错误。
若表的每一列声明为主键，或具有惟一性，如果对该列插入重复的值时将触发该异常。
示例：
CREATE TABLE test_table
(
v_id NUMBER PRIMARY KEY,
v_name VARCHAR2(20)
)
INSERT INTO test_table VALUES(1,'test1');
INSERT INTO test_table VALUES(2,'test2');
SELECT * FROM test_table;
BEGIN
UPDATE test_table SET v_name = new_name WHERE v_id = &input_id;
EXCEPTION
WHEN dup_val_on_index THEN
dbms_output.put_line('在deptno列上不能出现重复值.');
END;
/
7 CASE_NOT_FOUND该异常触发ORA-06592错误。
在CASE语句中，如果CASE语句的条件在WHEN子句中没有找到对应的条件分支，且该CASE语句不包含ELSE分支，将触发该异常。
示例：
DECLARE
v_test NUMBER;
BEGIN
SELECT val INTO v_test FROM dual;
CASE
WHEN v_test = 1 THEN
dbms_output.put_line(v_test);
WHEN v_test = 2 THEN
dbms_output.put_line(v_test);
WHEN v_test = 3 THEN
dbms_output.put_line(v_test);
--ELSE
-- dbms_output.put_line(v_test);
END CASE;
EXCEPTION
WHEN case_not_found THEN
dbms_output.put_line('在CASE语句中没有与' || v_test || '相关的条件.');
END;
/
8 ZERO_DIVIDE该异常触发ORA-01476错误。
当在程序中使用0作为除数进行运算时，将触发该异常。
示例：
DECLARE
v_test1 NUMBER := 100;
v_test2 NUMBER := 0;
v_test3 NUMBER := 0;
BEGIN
v_test3 := v_test1 / v_test2;
dbms_output.put_line(v_test3);
EXCEPTION
WHEN zero_divide THEN
dbms_output.put_line('0不能作为除数.');
END;
/
9 INVALID_NUMBER该异常触发ORA-01722错误。
数字或值错误，或字符到数值的转换错误。
示例：
BEGIN
UPDATE emp SET sal = sal + '1oo'; -- 1oo
EXCEPTION
WHEN invalid_number THEN
dbms_output.put_line('输入的数字不正确.');
END;
/
DECLARE
v_test NUMBER;
v_test2 NUMBER;
BEGIN
v_test := '100';
v_test2 := '1a';
dbms_output.put_line(v_test);
EXCEPTION
WHEN INVALID_NUMBER THEN
DBMS_OUTPUT.PUT_LINE('输入的数字不正确.');
END;
/
10 ACCESS_INTO_NULL该异常触发ORA-06530错误。
当程序中的对象还没有先进行对象初始化的操作，就直接为对象的属性赋值，将触发该异常。
示例：
DECLARE
v_test test_type;
BEGIN
v_test.v_name := 'test';
EXCEPTION
WHEN access_into_null THEN
dbms_output.put_line('首先初始化对象v_test');
END;
/
11 COLLECTION IS NULL该异常触发ORA-06531错误。
在给集合元素赋值前，必须先初始化该集合元素，否则触发该异常。
示例：
DECLARE
TYPE emp_ssn_array IS TABLE OF NUMBER/* INDEX BY BINARY_INTEGER*/;
best_employees emp_ssn_array;
BEGIN
best_employees(0) := '123456';
dbms_output.put_line('best_employees(0): ' || best_employees(0));
EXCEPTION
WHEN collection_is_null THEN
dbms_output.put_line('必须初始化集合元素.');
END;
/
12 SUBSCRIPT_BEYOND_COUNT该异常触发ORA-06533错误。
当使用复合数据类型时，如果下标越界触发该异常。
示例：
DECLARE
TYPE test_array IS VARRAY(20) OF NUMBER;
v_test test_array;
BEGIN
v_test := test_array(123456);
dbms_output.put_line('v_test(1): ' || v_test(2));
EXCEPTION
WHEN subscript_beyond_count THEN
dbms_output.put_line('下标越界.');
END;
/
13 SUBSCRIPT_OUTSIDE_LIMIT该异常触发ORA-06532错误，当使用复合数据类型时，如果下标为负值时触发该异常。
示例：
DECLARE
TYPE test_array IS VARRAY(20) OF NUMBER;
v_test test_array;
BEGIN
v_test := test_array(123456);
dbms_output.put_line('v_test(-1): ' || v_test(-1));
EXCEPTION
WHEN subscript_outside_limit THEN
dbms_output.put_line('下标不能是负数.');
END;
/
14 LONIN_DENIED该异常触发ORA_01017错误。
当PL/SQL连接数据库时，如果密码错误，将触发该异常。
15 NOT_LOGGED_ON该异常触发ORA-01012错误。
如果PL/SQL没有连接数据库，程序运行将触发该异常。
16 PROGRAM_ERROR该异常触发ORA-06501错误。
如果出现该异常，则表示PL/SQL的内部问题。用户可能需要重新安装数据字典和PL/SQL系统包。
17 ROWTYPE MISMATCH该异常触发ORA-06504错误。
在赋值时，如果宿主游标变量和PL/SQL游标变量的返回类型不兼容，将触发该异常。
18 SELF_IF_NULL该异常触发ORA-30625错误。
在使用对象类型时，如果在NULL示例上调用成员方法将触发该异常。
19 STORAGE_ERROR该异常触发ORA-06500错误。
当PL/SQL块运行时，如果走出内在空间或内在被损坏则触发该异常。
20 SYS_INVALID_ROWID该异常触发ORA-01410错误。
当将字符串转变为ROWID时，如果使用了无效的字符串则触发该异常。
21 TIMEOUT_ON_RESOURCE该异常触发ORA-00051错误。
Oracle在等待资源时出现超时错误时将触发该异常。
22 ORA-04021Oracle在等待资源时出现超时错误，该资源可能被其它session锁住，此时将触发该异常。
23 ORA-01791 不是Selected表达式SELECT DISTINCT goodsid,
barcode,
depotid,
goodsname
FROM sa_sale
WHERE depotid = '11'
ORDER BY selldate
这句话执行的时候就有错误， 但把排序换成 order by  Goodsid 或其它 Barcode,DepotId,GoodsName的时候均没有错误，这是因为 selldate不在查询结果字段中，而且这个语句是distinct语句。所以会出现这个错误
下边给出正确的解决办法：
SELECT goodsid,
barcode,
depotid,
goodsname
FROM (SELECT DISTINCT goodsid,
barcode,
depotid,
goodsname,
selldate
FROM sa_sale
WHERE depotid = '11')
ORDER BY selldate
24 ORA-01002: fetch out of sequence当游标中数据集已经取完，然后再一次进行FETCH操作时将触发该异常。
25 PLS-00382: expression is of wrong type表达式类型错误。即在代码中赋予操作的左右两边的类型不等。
二 非预定义异常使用非预定义异常的步骤如下：
定义异常 -> 关联异常和错误 -> 引用例外
当定义Oracle错误和例外之间的关联关系时，要使用伪过程EXCEPTION_INTI。
下面以处理ORA-02291错误为例说明：
DECLARE
e_integrity EXCEPTION;
PRAGMA EXCEPTION_INIT(e_integrity, -2291);
BEGIN
UPDATE emp SET deptno = dno WHERE empno = &eno;
EXCEPTION
WHEN e_integrity THEN
dbms_output.put_line('该部门不存在.');
END;
/
三 自定义异常使用预定义异常和非预定义异常，程序可以捕获Oracle错误，并且在出现Oracle错误时自动触发对应的异常。但是在实际应用中，可能还会遇到其它错误，这时，可以为特定的情况自定义异常，不过需要显示触发该异常：通过定义异常，然后关联异常和错误，显示触发异常，最后在EXCEPTION中处理该异常。
示例：
DECLARE
l_error_message VARCHAR2(200);
e_user_exception EXCEPTION;
BEGIN
** ** ** ** **;
IF '出现错误' THEN
l_error_message := '定义错误信息';
RAISE e_user_exception;
END IF;
EXCEPTION
WHEN e_user_exception THEN
raise_application_error(-20001, l_error_message);
END;
/
四 例外函数1 SQLCODE，SQLERRM在PL/SQL块中出现Oracle错误时,通过使用例外函数可以取得错误号以及相关的错误消息。
SQLCODE 返回Oracle错误号。
SQLERRM 返回错误号对应的错误消息。
示例：
DECLARE
v_ename emp.ename%TYPE;
BEGIN
SELECT ename INTO v_ename FROM emp WHERE sal = &v_sal;
dbms_output.put_line('雇员名:' || v_ename);
EXCEPTION
WHEN NO_DATA_FOUND THEN
dbms_output.put_line('不存在工资为' || v_sal || '雇员');
WHEN OTHERS THEN
dbms_output.put_line('错误号' || SQLCODE);
dbms_output.put_line(SQLERRM);
END;
/
2 RAISE_APPLICATION_ERROR在存储过程,函数和包中使用RAISE_APPLICATION_ERROR可以自定义错误号和消息。
raise_application_error：用于自定义错误消息(用于程序段中) 
语法：
raise_application_error(error_number,message[,{TRUE | FALSE}]);
error_number : 错误号,范围是: -20000 ~ -20999之间的负整数;
message : 错误消息,长度不能超过2048字节;
第三个可靠选参数,如果TRUE,该错误会被放在先前错误堆栈中;如果FALSE(默认),则替换先前所有错误.
示例：
CREATE OR REPLACE PROCEDURE raise_comm
(
eno NUMBER,
commission NUMBER
) IS
v_comm emp.comm%TYPE;
BEGIN
SELECT comm INTO v_comm FROM emp WHERE emp = eno;
IF v_comm IS NULL THEN
raise_application_error(-20001, '该员工无补助.');
END IF;
EXCEPTION
WHEN NO_DATA_FOUND THEN
dbms_output.put_line('该雇员不存在.');
END;
/
 
 
 
１：预定义异常       用于处理常见的Oracle错误
２：非预定义异常    用于处理预定义异常所不能处理的Oracle错误
３：自定义异常       用于处理于Oracle错误无关的其他情况
异常处理部分是以关键字EXCEPTION开始的，语法如下：
EXCEPTION
WHENexception_NameTHEN --exception_Name为异常的名字
   statement1;
WHENOTHERSTHEN
statement1;

异常处理部分从关键字EXCEPTION开始，在异常处理部分使用WHEN字句捕捉各种异常，如果有其他未预定义到的异常，使用WHENOTHERSTHEN字句进行捕捉和处理。
1、处理预定义异常，这是系统预定的21种类型
错误代码是负整数，如-51
Access_info_null（ora-06530）
当访问没有初始化的对象时触发。
Case_not_found(ora-06592)
case过程中when后没有包含必要的条件分支并且没有else子句，则会触发本异常。
Collection_is_null(06531)
访问未初始化的集合元素（嵌套表或者varray）。
Cursor_already_open(ora-06511)
重新打开已经打开的游标。
Dup_val_on_index(ora-00001)
当中唯一索引所对应的列上键入重复值时。
Invalid_cursor(ora-01001)
试图在不合法的游标上执行操作时，譬如没打开游标就提取内容
Invalid_number(ora-01722)
当试图将非法的字符串转换为数字类型时。
No_data_found(ora-01403)
执行select into未返回行，或者引用了索引表未初始化的元素时。
Too_many_rows(ora-01422)
执行select into返回超过一行数据时。
Zero_divide(ora-01476)
0作为被除数时。
Subscript_beyond_count(ora-06533)
使用嵌套表或者varray集合时，如果引用下标超过last。
Subscript_outside_limit(ora-06532)
使用嵌套表或varray集合时，如果引用下标小于first。
Value_error(ora-06502)
在执行赋值操作时，如果变量长度不足以容纳实际数据。
Login_denied(ora-01017)
连接数据库时提供了不正确的用户名或口令。
Not_logged_on(ora-01012)
在程序没有连接到oracle数据库时执行plsql代码则会触发。
Program_error(ora-06501)
plsql内部问题。
Rowtype_mismatch(ora-06504)
执行赋值操作时，如果宿主游标变量和PLSQL游标变量返回类型不兼容时。
Self_is_null(ora-30625)
使用对象类型时，如果在null实例上调用成员方法。
Storage_error(ora-06500)
超出内存空间或者内存被损坏。
Sys_invalid_rowid（ora-01410）
无效字符串企图转换为rowid类型时。
Timeout_on_resource(ora-00051)
等待资源时出现超时错误。

2、处理非预定义异常
使用非预定义异常包括三步：
一：在定义部分定义异常名，
二：在异常和Oracle错误之间建立关联，
三：在异常处理部分捕捉并处理异常。
当定义Oracle错误和异常之间的关联关系时，需要使用伪过程EXCEPTION_INIT。
一：首先的定义部分定义异常；
二：使用progma exception_init(exception_name,exception_number)在异常和oracle错误之间建立关联，
   这时要求用户知道可能出现的错误号（异常函数sqlcode、sqlerrm和raise_application_error）；
三：最终在异常处理部分捕捉并处理异常。
下面以更新特定雇员的部门号，并处理ORA-02291错误为例，说明使用非预定义异常的方法。示例如下：
DECLARE
e_integrity EXCEPTION;--1、定义部分
PRAGMA EXCEPTION_INIT(e_integrity,-2291); --2、建立关联关系
BEGIN
UPDATEempSETdeptno=&dnoWHEREempno=&eno;
EXCEPTION
WHENe_integrityTHEN --3、捕捉处理
   DBMS_OUTPUT.PUT_LINE(‘该部门不存在’);
END;

--3、处理自定义异常
预定义异常和非预定义异常都与Oracle错误有关，并且当出现Oracle错误时会隐含触发相应异常；
而自定义异常与Oracle错误没有任何关联，它是由开发人员为特定情况所定义的异常。
当使用自定义异常时，
一：需要在定义部分（DECLARE）定义异常，
二：再执行部分（BEGIN）触发异常（使用RAISE语句），
三：在异常处理部分（EXCEPTION）捕捉并处理异常。
declare
myexceptionexception;
begin
if　1=0　then
   raisemyexception;
endif;
exception
when　myexception　then
    dbms_output.put_line('asdf');
end;
注意：不能在同一个block中描述EXCEPTION两次，但是可以描述一个exception在两个不同的block中。异常（exception）是有作用域的，子块的异常不能被当前块所捕捉，
--４、使用异常函数：
Oracle内置函数sqlcode和sqlerrm主要用在others处理器中，分别用来返回oracle的错误代码和错误消息。
一般情况下sqlcode返回负数标识的oracle错误代码，除非错误为‘ora-01403：no data found’，此时对应的sqlcode为+100，
对于用户自定义的异常，sqlcode返回+1，如果没有异常被触发，sqlcode返回0。
Begin
Exception
Whenothersthen
   Dbms_output.put_line(sqlcode||sqlerrm(sqlcode));
End;

Oracle过程raise_application_error用于在plsql应用程序中自定义错误消息。
注意该过程只能在数据库端的子程序（过程、函数、包、触发器）中使用，而不能在匿名块和客户端的子程序中使用。
语法为raise_application_error(error_number,message[,[true|false]]);
其中
error_number用于定义错误号，该错误号必须在-20000到-20999之间的负整数；
message用于指定错误消息，并且该消息的长度不能超过2048字节；
第三个参数如果为true，则该错误会被放在先前错误堆栈中，如果为false（默认值）则会替代先前所有错误。
IFproduct_not_foundTHEN
           RAISE_APPLICATION_ERROR(-20123,'Invald product code'TRUE);
ENDIF;
--５、plsql编译警告：
plsql警告可以分为四类：
severe：用于检查可能出现的不可预料或者错误结果，例如参数的别名问题；
performance：用于检查可能引起的性能问题，例如执行insert操作时为number列提供了varchar2类型数据；
informational：用于检查子程序中的死代码；
all：用于检查所有警告。
为了数据库可以在编译plsql子程序时发出警告信息，需要设置初始化参数plsql_warnings。这个参数不仅可以在系统级或者会话级设置，也可以在alter procedure命令中设置。
Alter{system|session|procedure}
setplsql_warnings=
　　’{enable|disable:{all|performance|severe|informational}}’;
为了检查是否存在对应警告信息，必须先激活警告检查，然后重新编译子程序，最后使用show errors命令显示警告错误。
createorreplaceproceduremy_test
is
begin
if1=0then
   dbms_output.put_line('test');
endif;
end;
SQL>alterproceduremy_test compile plsql_warnings='enable:all';
Procedurealtered
SQL>show errors;
ErrorsforPROCEDURESYS.MY_TEST:
LINE/COL ERROR
------- -------------------------
10/5    PLW-06002:无法执行的代码
--6、定义Exception时要注意的一些事项
当异常发生时，在块的内部没有该异常处理器时，控制将转到或传播到上一层块的异常处理部分。
没有处理的异常将沿检测异常调用程序传播到外层，当异常被处理并解决或到达程序最外层传播停止。在声明部分抛出的异常将控制转到上一层的异常部分。
用户必须在独立的WHEN子串中为每个异常设计异常处理代码，WHEN OTHERS子串必须放置在最后面作为缺省处理器处理没有显式处理的异常。当异常发生时，控制转到异常部分，ORACLE查找当前异常相应的WHEN..THEN语句，捕捉异常，THEN之后的代码被执行，如果错误陷阱代码只是退出相应的嵌套块，那么程序将继续执行内部块END后面的语句。如果没有找到相应的异常陷阱，那么将执行WHEN OTHERS。在异常部分WHEN子串没有数量限制。
 
 Copyright ©2010 lyt. All Rights Reserved.





study
ORACLE 错误一览表(10601 - 13400)

ORA-10601: turn on debugging for cursor_sharing (literal replacement) 
ORA-10602: cause an access violation (for testing purposes) 
ORA-10603: cause an error to occur during truncate (for testing purposes) 
ORA-10604: trace parallel create index 
ORA-10605: enable parallel create index by default 
ORA-10606: trace parallel create index 
ORA-10607: trace index rowid partition scan 
ORA-10608: trace create bitmap index 
ORA-10609: trace for array index insertion 
ORA-10610: trace create index pseudo optimizer 
ORA-10611: causes migration to fail - testing only 
ORA-10612: prints debug information for auto-space managed segments 
ORA-10613: prints debug information for auto-space managed segments 
ORA-10614: Operation not allowed on this segment 
ORA-10615: Invalid tablespace type for temporary tablespace 
ORA-10616: Operation not allowed on this tablespace 
ORA-10617: Cannot create rollback segment in dictionary managed tablespace 
ORA-10618: Operation not allowed on this segment 
ORA-10619: Avoid assertions when possible 
ORA-10620: Operation not allowed on this segment 
ORA-10621: data block does not belong to the segment 
ORA-10622: test/trace online index (re)build 
ORA-10623: Enable Index range scan Prefetch - testing only 
ORA-10624: Disable UJV invalidation on drop index 
ORA-10640: Operation not permitted during SYSTEM tablespace migration 
ORA-10641: Cannot find a rollback segment to bind to 
ORA-10642: Found rollback segments in dictionary managed tablespaces 
ORA-10643: Database should be mounted in restricted mode and Exclusive mode 
ORA-10644: SYSTEM tablespace cannot be default temporary tablespace 
ORA-10645: Recursive Extension in SYSTEM tablespace during migration 
ORA-10646: Too many recursive extensions during SYSTEM tablespace migration 
ORA-10647: Tablespace other than SYSTEM,, not found in read only mode 
ORA-10650: disable cache-callback optimisation 
ORA-10651: incorrect file number block number specified 
ORA-10666: Do not get database enqueue name 
ORA-10667: Cause sppst to check for valid process ids 
ORA-10700: Alter access violation exception handler 
ORA-10701: Dump direct loader index keys 
ORA-10702: Enable histogram data generation 
ORA-10703: Simulate process death during enqueue get 
ORA-10704: Print out information about what enqueues are being obtained 
ORA-10705: Print Out Tracing information for every I/O done by ODSs 
ORA-10706: Print out information about global enqueue manipulation 
ORA-10707: Simulate process death for instance registration 
ORA-10710: trace bitmap index access 
ORA-10711: trace bitmap index merge 
ORA-10712: trace bitmap index or 
ORA-10713: trace bitmap index and 
ORA-10714: trace bitmap index minus 
ORA-10715: trace bitmap index conversion to rowids 
ORA-10716: trace bitmap index compress/decompress 
ORA-10717: trace bitmap index compaction trace for index creation 
ORA-10718: event to disable automatic compaction after index creation 
ORA-10719: trace bitmap index dml 
ORA-10720: trace db scheduling 
ORA-10721: Internal testing - temp table transformation 
ORA-10723: Internal testing - release buffer for buffer cache shrink 
ORA-10724: trace cross-instance broadcast 
ORA-10730: trace row level security policy predicates 
ORA-10731: dump SQL for CURSOR expressions 
ORA-10740: disables fix for bug 598861 
ORA-10750: test rollback segment blksize guessing for index array insert 
ORA-10800: disable Smart Disk scan 
ORA-10801: enable Smart Disk trace 
ORA-10802: reserved for Smart Disk 
ORA-10803: write timing statistics on cluster database recovery scan 
ORA-10804: reserved for ksxb 
ORA-10806: Switch to 7.3 mode when detaching sessions 
ORA-10807: Disable user id check when switching to a global transaction 
ORA-10810: Trace snapshot too old 
ORA-10811: Trace block cleanouts 
ORA-10812: Trace Consistent Reads 
ORA-10826: enable upgrade/downgrade error message trace 
ORA-10827: database must be opened with MIGRATE option 
ORA-10830: Trace group by sort row source 
ORA-10831: Trace group by rollup row source 
ORA-10841: Default un-inintialized charact set form to SQLCS_IMPLICIT 
ORA-10842: Event for OCI Tracing and Statistics Info 
ORA-10850: Enable time manager tracing 
ORA-10851: Allow Drop command to drop queue tables 
ORA-10852: Enable dumping of the AQ statistics hash table 
ORA-10853: event for AQ statistics latch cleanup testing 
ORA-10856: Disable AQ propagator from using streaming 
ORA-10857: Force AQ propagator to use two-phase commit 
ORA-10859: Disable updates of message retry count 
ORA-10860: event for AQ admin disable new name parser 
ORA-10861: disable storing extended message properties 
ORA-10862: resolve default queue owner to current user in enqueue/dequeue 
ORA-10900: extent manager fault insertion event # 
ORA-10902: disable seghdr conversion for ro operation 
ORA-10903: Force tablespaces to become locally managed 
ORA-10904: Allow locally managed tablespaces to have user allocation 
ORA-10907: Trace extent management events 
ORA-10908: Trace temp tablespace events 
ORA-10909: Trace free list events 
ORA-10911: Locally managed SYSTEM tablespace bitmaps can be modified only under the supervision of Oracle Support 
ORA-10912: Used to perform admin operations on locally managed SYSTEM tablespace 
ORA-10913: Create locally managed database if compatible > 920 by default 
ORA-10924: import storage parse error ignore event 
ORA-10925: trace name context forever 
ORA-10926: trace name context forever 
ORA-10927: trace name context forever 
ORA-10928: trace name context forever 
ORA-10929: trace name context forever 
ORA-10930: trace name context forever 
ORA-10931: trace name context forever 
ORA-10932: trace name context forever 
ORA-10933: trace name context forever 
ORA-10934: Reserved. Used only in version 7.x. 
ORA-10935: Reserved. Used only in version 7.x. 
ORA-10936: trace name context forever 
ORA-10937: trace name context forever 
ORA-10938: trace name context forever 
ORA-10939: trace name context forever 
ORA-10940: trace name context forever 
ORA-10941: trace name context forever 
ORA-10943: trace name context forever 
ORA-10944: trace name context forever 
ORA-10945: trace name context forever 
ORA-10975: trace execution of parallel propagation 
ORA-10976: internal package related tracing 
ORA-10977: trace event for RepAPI 
ORA-10979: trace flags for join index implementation 
ORA-10980: prevent sharing of parsed query during Materialized View query generation 
ORA-10981: dscn computation-related event in replication 
ORA-10982: event to turn off CDC-format MV Logs 
ORA-10983: event to enable Create_Change_Table debugging 
ORA-10984: subquery materialized view-related event 
ORA-10985: event for NULL refresh of materialized views 
ORA-10986: donot use HASH_AJ in refresh 
ORA-10987: event for the support of caching table with object feature 
ORA-10988: event to get exclusive lock during materialized view refresh in IAS 
ORA-10989: event to internally create statistics MV 
ORA-10996: event to make a process hold a latch in ksu 
ORA-10999: do not get database enqueue name 
ORA-12000: 实体化视图日志已经存在于表 '' 上
 ORA-12001: 无法创建日志: 表''已经具有触发器 
ORA-12002: 表 ""."" 上不存在任何实体化视图日志 
ORA-12003: 实体化视图 ""."" 不存在 
ORA-12004: REFRESH FAST 不能用于实体化视图 ""."" 
ORA-12005: 不可以安排过去时间的自动刷新 
ORA-12006: 具有相同 user.name 的实体化视图已经存在 
ORA-12007: 实体化视图重新使用的参数不一致 
ORA-12008: 实体化视图的刷新路径中存在错误 
ORA-12009: 实体化视图不能包含 long 列 
ORA-12010: 不能在 SYS 拥有的表上创建实体化视图日志 
ORA-12011: 无法执行 作业 
ORA-12012: 自动执行作业 出错 
ORA-12013: 可更新实体化视图必须足够简单, 以进行快速刷新 
ORA-12014: 表''不包含主键约束条件 
ORA-12015: 不能从复杂查询中创建一个可快速刷新的实体化视图 
ORA-12016: 实体化视图并未包含所有主键列 
ORA-12017: 不能将主键实体化视图 '' 更改为 rowid 实体化视图 
ORA-12018: 在创建""."" 的代码时出现以下错误 
ORA-12019: 主表与远程对象同义 
ORA-12020: 实体化视图 未注册 
ORA-12021: 实体化视图 ""."" 已损坏 
ORA-12022: ""."" 上的实体化视图日志已具有 rowid 
ORA-12023: 实体化视图 ""."" 上缺少索引 
ORA-12024: ""."" 上的实体化视图日志没有主键列 
ORA-12025: ""."" 上的实体化视图日志已有主键 
ORA-12026: 检测到无效的过滤器列 
ORA-12027: 过滤器列重复 
ORA-12028: 主体站点 不支持实体化视图类型 
ORA-12029: LOB 列不可以用作过滤评感 
ORA-12030: 不能创建可快速刷新的实体化视图 
ORA-12031: 不能使用 ""."" 上实体化视图日志中的主键列 
ORA-12032: 不能使用 ""."" 上实体化视图日志中的 rowid 列 
ORA-12033: 不能使用 ""."" 上实体化视图日志中的过滤器列 
ORA-12034: ""."" 上的实体化视图日志比上次刷新后的内容新 
ORA-12035: 无法使用 ""."" 上的实体化视图日志 
ORA-12036: 可更新的实体化视图日志非空, 请刷新实体化视图 
ORA-12037: 未知的导出格式 
ORA-12038: 文字字符串具有未预期的长度 
ORA-12039: 无法使用本地回退段"" 
ORA-12040: 主地点 不支持主回退段选项 
ORA-12041: 无法记录索引编排表"".""的 ROWID 
ORA-12042: 在单一进程模式下无法更改 job_queue_processes 
ORA-12043: CREATE MATERIALIZED VIEW 选项无效 
ORA-12044: CREATE MATERIALIZED VIEW LOG 选项无效 
ORA-12045: ALTER MATERIALIZED VIEW LOG 选项无效 
ORA-12051: ON COMMIT 属性与其它选项不兼容 
ORA-12052: 无法快速刷新实体化视图 . 
ORA-12053: 这不是一个有效的嵌套实体化视图 
ORA-12054: 无法为实体化视图设置 ON COMMIT 刷新属性 
ORA-12055: 实体化视图定义与现有实体化视图具有循环相关性 
ORA-12056: 无效的 REFRESH 方式 
ORA-12057: 实体化视图 ""."" 无效, 必须进行完全刷新 
ORA-12058: 实体化视图不能使用预建表 
ORA-12059: 预建表 ""."" 不存在 
ORA-12060: 预建表的形式与定义查询不匹配 
ORA-12061: ALTER MATERIALIZED VIEW 选项无效 
ORA-12062: 接收到的事务处理 在来自站点 的事务处理序列之外 
ORA-12063: 无法从站点 应用事务处理 
ORA-12064: 无效的刷新序列编号: 
ORA-12065: 未知的刷新组标识符 
ORA-12066: CREATE MATERIALIZED VIEW 命令无效 
ORA-12067: 不允许刷新组为空 
ORA-12068: 用于实体化视图 ""."" 的可更新实体化视图日志不存在 
ORA-12069: 无效的脱机例程的对象 
ORA-12070: 无法对实体化视图 ""."" 进行脱机实例化 
ORA-12071: ""."" 的定义查询对脱机示例化无效 
ORA-12072: 无法创建 ""."" 的可更新实体化视图日志数据。 
ORA-12073: 无法处理请求 
ORA-12074: 无效的内存地址 
ORA-12075: 无效的对象或字段 
ORA-12076: 无效的阈值 
ORA-12077: 临时可更新实体化视图日志不存在 
ORA-12078: 对刷新组 ID 的快速刷新失败 
ORA-12079: 实体化视图选项要求 COMPATIBLE 参数为 或更大的值 
ORA-12081: 不允许对表 ""."" 进行更新操作 
ORA-12082: ""."" 无法按索引组织 
ORA-12083: 必须使用 DROP MATERIALIZED VIEW 来删除 ""."" 
ORA-12084: 必须使用 ALTER MATERIALIZED VIEW 来更改 ""."" 
ORA-12085: ""."" 上的实体化视图日志已有对象 ID 
ORA-12086: 表 ""."" 不是对象表 
ORA-12087: 在 "" 拥有的表上不允许联机重新定义 
ORA-12088: 不能联机重新定义具有不受支持数据类型的表 ""."" 
ORA-12089: 不能联机重新定义无主键的表 ""."" 
ORA-12090: 不能联机重新定义表 ""."" 
ORA-12091: 不能联机重新定义具有实体化视图的表 ""."" 
ORA-12092: 不能联机重新定义复制的表 ""."" 
ORA-12093: 中间表 ""."" 无效 
ORA-12094: 联机重新定义过程中出错 
ORA-12096: ""."" 上的实体化视图日志中存在错误 
ORA-12097: changes in the master tables during refresh, try refresh again 
ORA-12150: TNS: 无法发送数据 
ORA-12151: TNS: 从网络层收到错误类型的信息包 
ORA-12152: TNS: 无法发送中断信息 
ORA-12153: TNS: 未连接 
ORA-12154: TNS: 无法处理服务名 
ORA-12155: TNS: 在 NSWMARKER 包中收到错误的数据类型 
ORA-12156: TNS: 尝试在错误状态之下重置线路 
ORA-12157: TNS: 内部网络通信错误 
ORA-12158: TNS: 无法初始化参数子系统 
ORA-12159: TNS: 跟踪文件不可写 
ORA-12160: TNS: 内部错误: 错误编号不正确 
ORA-12161: TNS: 内部错误: 收到部分数据 
ORA-12162: TNS: 指定的服务名不正确 
ORA-12163: TNS: 连接描述符过长 
ORA-12164: TNS: Sqlnet.fdf 文件不存在 
ORA-12165: TNS: 尝试将跟踪文件写入交换空间。 
ORA-12166: TNS: 客户无法连接到 HO 代理 
ORA-12168: TNS: 无法联系目录服务器。 
ORA-12169: TNS: 给定的 net_service_name 太长 
ORA-12170: TNS: 出现连接超时 
ORA-12196: TNS: 从 TNS 收到一则错误信息 
ORA-12197: TNS: 关键字值分解错误 
ORA-12198: TNS: 无法找到到达目标的路径 
ORA-12200: TNS: 无法分配内存 
ORA-12201: TNS: 连接缓冲区过小 
ORA-12202: TNS: 内部定位 (navigation) 错误 
ORA-12203: TNS: 无法连接目标 
ORA-12204: TNS: 从应用程序中收到拒绝的数据 
ORA-12205: TNS: 无法获得失败地址 
ORA-12206: TNS：导航时收到 TNS 错误 
ORA-12207: TNS：无法执行导航 
ORA-12208: TNS: 无法找到 TNSNAV.ORA 文件 
ORA-12209: TNS: 出现未初始化全局错误 
ORA-12210: TNS: 查找浏览器数据时出错 
ORA-12211: TNS: TNSNAV.ORA 中需要 PREFERRED_CMANAGERS 条目 
ORA-12212: TNS: TNSNAV.ORA 中连结 (binding) 的 PREFERRED_CMANAGERS 不完整 
ORA-12213: TNS: TNSNAV.ORA 中连结 (binding) 的 PREFERRED_CMANAGERS 不完整 
ORA-12214: TNS: TNSNAV.ORA 中缺少本地共用条目 
ORA-12216: TNS: 在 TNSNAV.ORA 中的 PREFERRED_CMANAGERS 地址形式不正确 
ORA-12217: TNS: 无法联系 TNSNAV.ORA 中的 PREFERRED_CMANAGERS 
ORA-12218: TNS: 无法接受的网络配置数据 
ORA-12219: TNS: ADDRESS_LIST 中的地址缺少共用名 
ORA-12221: TNS: 非法的 ADDRESS 参数 
ORA-12222: TNS: 没有这样的协议适配器 
ORA-12223: TNS: 超出内部限制 
ORA-12224: TNS: 没有监听器 
ORA-12225: TNS: 无法到达目的地主机 
ORA-12226: TNS: 超出操作系统资源限量 
ORA-12227: TNS: 语法错误 
ORA-12228: TNS: 协议适配器不可加载 
ORA-12229: TNS: 交换没有其它的可用连接 
ORA-12230: TNS: 进行此连接时出现严重的网络错误 
ORA-12231: TNS: 无法连接到目的地 
ORA-12232: TNS: 没有达到目的地的可用路径 
ORA-12233: TNS: 无法接受连接 
ORA-12234: TNS: 重定向到目的地 
ORA-12235: TNS: 无法重定向到目的地 
ORA-12236: TNS: 未加载协议适配器 
ORA-12315: ALTER DATABASE 语句的数据库链接类型无效 
ORA-12316: 数据库链接连接字符串语法错误 
ORA-12317: 连接数据库 (链接名称 ) 被拒绝 
ORA-12318: 已经装载数据库 (链接名称 ) 
ORA-12319: 数据库 (链接名称 ) 已经打开 
ORA-12321: 数据库 (链接名称 ) 没打开，并且 AUTO_MOUNTING=FALSE 
ORA-12322: 无法装载数据库 (链接名称 ) 
ORA-12323: 无法打开数据库 (链接名称 ) 
ORA-12324: 不能使用 ROM: 在个人数据库链接上的链接类型 
ORA-12326: 将立即关闭数据库 ；不允许任何操作 
ORA-12329: 数据库 已关闭； 不允许任何操作 
ORA-12333: 没装载数据库 (链接名称 ) 
ORA-12334: 数据库 (链接名称 ) 仍然打开 
ORA-12335: 数据库 (链接名称 ) 没打开 
ORA-12336: 不能连接到数据库 (链接名称 ) 
ORA-12341: 超出敞开装载最大数 
ORA-12342: 敞开装载超出 OPEN_MOUNTS 参数的限制 
ORA-12345: 用户 不具有在数据库链 (链接名称 ) 上的 CREATE SESSION 权限 
ORA-12350: 正在丢弃的数据链仍然装载 
ORA-12351: 无法用引用远程对象的远程对象创建视图 
ORA-12352: 对象 .@ 无效 
ORA-12353: 二次存储对象无法引用远程对象 
ORA-12354: 正在丢弃次要对象 
ORA-12400: 无效的功能错误处理参数 
ORA-12401: 无效的标记字符串: 
ORA-12402: 无效的格式字符串: 
ORA-12403: 无法的内容标签 
ORA-12404: 无效的权限字符串: 
ORA-12405: 无效的标记列表 
ORA-12406: 未经策略 授权的 SQL 语句 
ORA-12407: 未经策略 授权的操作 
ORA-12408: 不被支持的操作: 
ORA-12409: 策略的策略启动故障 
ORA-12410: 策略: 的内部策略错误 
错误: 
ORA-12411: 无效的标记值 
ORA-12412: 未安装策略程序包 
ORA-12413: 标记不属于同一个策略 
ORA-12414: 内部 LBAC 错误: 
错误: 
ORA-12415: 指定的表中存在另一个数据类型列 
ORA-12416: 策略 未发现 
ORA-12417: 未找到数据库对象 "" 
ORA-12418: 未找到用户 
ORA-12419: 空二进制标签值 
ORA-12420: 需要的过程和函数不在策略程序包 "" 中 
ORA-12421: 不同大小的二进制标签 
ORA-12422: 超过最大策略数 
ORA-12423: 指定的位置无效 
ORA-12424: 长度超出二进制标签的大小 
ORA-12425: 不能为系统方案应用策略或设置授权 
ORA-12426: 无效的审计选项 
ORA-12427: 参数的无效输入值 
ORA-12428: 
ORA-12429: 超出标签范围列表 
ORA-12430: 无效的权限号 
ORA-12431: 无效的审计操作 
ORA-12432: LBAC 错误: 
ORA-12433: 创建触发器失败，策略未应用 
ORA-12434: 无效的审计类型: 
ORA-12435: 无效的审计成功: 
ORA-12436: 未指定策略选项 
ORA-12437: 无效的策略选项: 
ORA-12438: 重复的策略选项: 
ORA-12439: 策略选项的无效组合 
ORA-12440: 无足够的权限使用 SYSDBA 程序包 
ORA-12441: 策略 已经存在 
ORA-12442: 策略列 "" 已经被现有策略使用 
ORA-12443: 策略未应用于方案中的某些表 
ORA-12444: 策略已经应用于表 
ORA-12445: 不能更改列的 HIDDEN 属性 
ORA-12446: 无足够的权限对策略 进行管理 
ORA-12447: 策略 的策略角色已经存在 
ORA-12448: 策略 未应用于方案 
ORA-12449: 为用户指定的标签必须是 USER 类型的 
ORA-12450: 在 LBAC 初始化文件中禁用 LOB 数据类型 
ORA-12451: 未将标签指定为 USER 或 DATA 
ORA-12452: 标签标记 已经存在 
ORA-12453: 标签 已经存在 
ORA-12454: 标签 (用于策略 的) 不存在 
ORA-12461: 未定义的级别 (用于策略 的) 
ORA-12462: 未定义的隔室 (用于策略 的) 
ORA-12463: 未定义的组 (用于策略 的) 
ORA-12464: 标签组件 中有非法字符 
ORA-12465: 无权在指定组或划分上执行读取或写入操作 
ORA-12466: 默认级别大于用户的最大值 
ORA-12467: 最小值标签只能包含一个级别 
ORA-12468: 最大写入级别不等于最大读取级别 
ORA-12469: 未找到用于用户 或策略 的用户级别 
ORA-12470: NULL 或无效的用户标签: 
ORA-12471: 未授予用户访问指定划分或组的权限 
ORA-12476: 最小上界产生无效的 OS 标记 
ORA-12477: 最大下界产生无效的 OS 标记 
ORA-12479: 文件标记 必须等于 DBHIGH 
ORA-12480: 指定的清除标记不在有效的清除以内 
ORA-12481: 有效的标记不在程序单元清除范围以内 
ORA-12482: 内部 MLS 错误: 
错误: 
ORA-12483: 标记不在 OS 系统信任范围内 
ORA-12484: 无效 OS 标记 
ORA-12485: 新的有效标记不在有效清除范围内 
ORA-12486: 无法更改有效的最大和最小标记 
ORA-12487: 清除标记不在 DBHIGH 和 DBLOW 之间 
ORA-12488: 最大标记数不支配最小标记数 
ORA-12489: 默认标记不在清除范围内 
ORA-12490: DBHIGH 无法降低 
ORA-12491: DBHIGH 值不支配 DBLOW 
ORA-12492: DBLOW 无法更改 
ORA-12493: 无效的 MLS 二进制标记 
ORA-12494: 无法插入或删除一个级别，目录，或版本目录 
ORA-12495: 无法禁用已经启用的级别，目录，或版本目录 
ORA-12496: 无法更改现有级别，目录，或版本号 
ORA-12497: 最大合并目录数超过 
ORA-12498: 
ORA-12499: 
ORA-12500: TNS: 监听程序无法启动专用服务器进程 
ORA-12501: TNS: 监听程序无法衍生进程 
ORA-12502: TNS: 监听程序没有从客户机收到 CONNECT_DATA 
ORA-12504: TNS: 监听器在 CONNECT_DATA 中未获得 SID 
ORA-12505: TNS: 监听器无法处理连接描述符中所给出的 SID 
ORA-12506: TNS: 监听器在 CONNECT_DATA 中未获得 ALIAS 
ORA-12507: TNS: 监听器无法处理给定的 ALIAS 
ORA-12508: TNS: 监听器无法处理给定的 COMMAND 
ORA-12509: TNS: 监听器无法将客户重定向到服务处理程序 
ORA-12510: TNS: 临时数据库缺少资源 处理请求 
ORA-12511: TNS: 服务处理程序已找到但它并不接受连接 
ORA-12512: TNS: 服务处理程序已找到但它并未注册重定向地址 
ORA-12513: TNS: 服务处理程序已找到但它并未注册不同的协议 
ORA-12514: TNS: 监听进程不能解析在连接描述符中给出的 SERVICE_NAME 
ORA-12515: TNS: 监听进程无法找到该演示文稿的句柄 
ORA-12516: TNS: 监听程序无法找到匹配协议栈的可用句柄 
ORA-12517: TNS: 监听程序无法找到支持直接分发的服务处理程序 
ORA-12518: TNS: 监听程序无法分发客户机连接 
ORA-12519: TNS: 没有发现适用的服务处理程序 
ORA-12520: TNS: 监听程序无法找到需要的服务器类型的可用句柄 
ORA-12521: TNS: 监听程序无法解析连接描述符中给定的 INSTANCE_NAME 
ORA-12522: TNS: 监听程序未找到具有给定 INSTANCE_ROLE 的可用例程 
ORA-12523: TNS: 监听程序未找到适用于客户机连接的例程 
ORA-12524: TNS: 监听程序无法解析在连接描述符中指定的HANDLER_NAME 
ORA-12531: TNS: 无法分配内存 
ORA-12532: TNS: 无效的参数 
ORA-12533: TNS: 非法的 ADDRESS 参数 
ORA-12534: TNS: 操作不受支持 
ORA-12535: TNS: 操作超时 
ORA-12536: TNS: 操作可能阻塞 
ORA-12537: TNS: 连接已关闭 
ORA-12538: TNS: 没有这样的协议适配器 
ORA-12539: TNS: 缓冲区上溢或下溢 
ORA-12540: TNS: 超出内部限制 
ORA-12541: TNS: 没有监听器 
ORA-12542: TNS: 地址已被占用 
ORA-12543: TNS: 无法到达目的地主机 
ORA-12544: TNS: 上下文具有不同的 wait/test 函数 
ORA-12545: 因目标主机或对象不存在，连接失败 
ORA-12546: TNS: 许可被拒绝 
ORA-12547: TNS: 丢失联系 
ORA-12548: TNS: 不完整的读或写 
ORA-12549: TNS: 超出操作系统资源限量 
ORA-12550: TNS: 语法错误 
ORA-12551: TNS: 缺少关键字 
ORA-12552: TNS: 操作被中断 
ORA-12554: TNS: 当前操作仍在进行中 
ORA-12555: TNS: 许可被拒绝 
ORA-12556: TNS: 没有调用程序 
ORA-12557: TNS: 协议适配器不可加载 
ORA-12558: TNS: 未加载协议适配器 
ORA-12560: TNS: 协议适配器错误 
ORA-12561: TNS: 未知错误 
ORA-12562: TNS: 全局句柄错误 
ORA-12564: TNS: 拒绝连接 
ORA-12566: TNS: 协议错误 
ORA-12569: TNS: 包校验和失败 
ORA-12570: TNS: 包阅读程序失败 
ORA-12571: TNS: 包写入程序失败 
ORA-12574: TNS: 重定向被拒绝 
ORA-12582: TNS: 无效的操作 
ORA-12583: TNS: 没有阅读程序 
ORA-12585: TNS: 数据截断 
ORA-12589: TNS: 连接无法保留 
ORA-12590: TNS: 没有 I/O 缓冲区 
ORA-12591: TNS: 事件信号失败 
ORA-12592: TNS: 包错误 
ORA-12593: TNS: 没有注册连接 
ORA-12595: TNS: 没有确认 
ORA-12596: TNS: 内部不一致 
ORA-12597: TNS: 连接描述符已被占用 
ORA-12598: TNS: 标帜注册失败 
ORA-12599: TNS: 口令校验和不匹配 
ORA-12600: TNS: 字符串打开失败 
ORA-12601: TNS: 信息标志检查失败 
ORA-12602: TNS: 已经达到了连接共享的限制 
ORA-12604: TNS: 出现应用程序超时 
ORA-12611: TNS:操作不可移植 
ORA-12612: TNS:连接正忙 
ORA-12615: TNS:抢先错误 
ORA-12616: TNS: 没有事件信号 
ORA-12618: TNS: 版本不兼容 
ORA-12619: TNS: 无法授权请求的服务 
ORA-12620: TNS: 请求的特性不可用 
ORA-12622: TNS: 事件通知非同类 
ORA-12623: TNS: 此状态的操作非法 
ORA-12624: TNS: 连接已经注册 
ORA-12625: TNS: 缺少参数 
ORA-12626: TNS: 事件类型错误 
ORA-12628: TNS: 没有事件回调 
ORA-12629: TNS: 没有事件测试 
ORA-12630: 不支持本机服务操作 
ORA-12631: TNS: 用户名检索失败 
ORA-12632: 角色提取失败 
ORA-12633: 没有共享的验证服务 
ORA-12634: 内存分配失败 
ORA-12635: 没有可用的验证适配器 
ORA-12636: 包发送失败 
ORA-12637: 包接收失败 
ORA-12638: 身份证明检索失败 
ORA-12639: 验证服务协商失败 
ORA-12640: 验证适配器初始化失败 
ORA-12641: 验证服务无法初始化 
ORA-12642: 没有会话关键字 
ORA-12643: 客户机收到来自服务器的内部错误 
ORA-12644: 验证服务初始化失败 
ORA-12645: 参数不存在。 
ORA-12646: 指定用于布尔参数的值无效 
ORA-12647: 要求验证 
ORA-12648: 加密或数据完整性算法列表为空 
ORA-12649: 未知的加密或数据完整性算法 
ORA-12650: 没有共用的加密或数据完整性算法 
ORA-12651: 不能接受加密或数据完整性算法 
ORA-12652: 字符串被截断 
ORA-12653: 验证控制函数失败 
ORA-12654: 验证转换失败 
ORA-12655: 口令检查失败 
ORA-12656: 口令校验和不匹配 
ORA-12657: 未安装算法 
ORA-12658: 需要 ANO 服务但与 TNS 版本不兼容 
ORA-12659: 收到来自其他进程的错误 
ORA-12660: 加密或口令校验和参数不兼容 
ORA-12661: 将使用协议验证 
ORA-12662: 代理服务器记录单检索失败 
ORA-12663: 服务器未提供客户机要求的服务 
ORA-12664: 客户机未提供服务器要求的服务 
ORA-12665: NLS 字符串打开失败 
ORA-12666: 专用服务器: 出站传输协议不同于入站传输协议 
ORA-12667: 共享服务器：出站传输协议与入站传输协议不相同 
ORA-12668: 专用服务器: 出站协议不支持代理服务器 
ORA-12669: 共享服务器: 出站协议不支持代理服务器 
ORA-12670: 错误的角色口令 
ORA-12671: 共享服务器: 适配器无法保存上下文 
ORA-12672: 数据库登录失败 
ORA-12673: 专用服务器: 未保存上下文 
ORA-12674: 共享服务器: 未保存代理服务器上下文 
ORA-12675: 尚未提供外部用户名 
ORA-12676: 服务器收到来自客户机的内部错误 
ORA-12677: 数据库链接不支持验证服务 
ORA-12678: 验证已禁用, 但要求验证 
ORA-12679: 其他进程禁用本地服务, 但需要此服务 
ORA-12680: 本机服务已停止，但需要此服务 
ORA-12681: 登录失败: SecurID 卡尚无个人标识代码 
ORA-12682: 登录失败: SecurID 卡处于下一个 PRN 模式 
ORA-12683: 加密/口令校验和: 没有 Diffie-Hellman 源数据 
ORA-12684: 加密/口令校验和: Diffie-Hellman 源数据过小 
ORA-12685: 远程需要本机服务，但在本地已禁用 
ORA-12686: 为服务指定了无效的命令 
ORA-12687: 数据库链接失败: 身份证明失效 
ORA-12688: 登录失败: SecurID 服务器已拒绝新的个人标识代码 
ORA-12689: 需要服务器验证, 但不支持此验证 
ORA-12690: 服务器验证失败, 登录已被取消 
ORA-12696: 双重加密已启用，禁止登录 
ORA-12699: 本机服务内部错误 
ORA-12700: 无效的 NLS 参数值 () 
ORA-12701: CREATE DATABASE 字符集未知 
ORA-12702: SQL 函数中使用了无效的 NLS 参数字符串 
ORA-12703: 不支持此字符集转换 
ORA-12704: 字符集不匹配 
ORA-12705: 指定了无效或未知的 NLS 参数值 
ORA-12706: 不允许此 CREATE DATABASE 字符集 
ORA-12707: 获得创建数据库 NLS 参数 时出错 
ORA-12708: 加载创建数据库 NLS 参数 时出错 
ORA-12709: 加载创建数据库字符集时出错 
ORA-12710: CREATE CONTROLFILE 字符集不能识别 
ORA-12711: 该 CREATE CONTROLFILE 字符集不允许 
ORA-12712: 新字符集必须为旧字符集的超集 
ORA-12713: 在 NCHAR/CHAR 转换过程中字符数据丢失 
ORA-12714: 指定的国家字符集无效 
ORA-12715: 指定的字符集无效 
ORA-12716: 当存在 CLOB 数据时, 不能 ALTER DATABASE CHARACTER SET 
ORA-12717: 当存在 NCLOB 数据时, 不能 ALTER DATABASE CHARACTER SET 
ORA-12718: 操作要求以 SYS 身份连接 
ORA-12719: 操作要求数据库处于 RESTRICTED 模式下 
ORA-12720: 操作要求数据库处于 EXCLUSIVE 模式下 
ORA-12721: 当其他会话处于活动状态时, 无法执行操作 
ORA-12800: 系统对于并行查询执行显示过忙
 ORA-12801: 并行查询服务器 中发出错误信号 
ORA-12802: 并行查询服务器与协调程序失去联系 
ORA-12803: 并行查询服务器与另一服务器失去联系 
ORA-12804: 并行查询服务器可能停止 
ORA-12805: 并行查询服务器意外停止 
ORA-12806: 无法获得要挂起入队的背景进程 
ORA-12807: 进程队列无法接收并行查询信息 
ORA-12808: 设置的 _INSTANCES 不能大于例程数 
ORA-12809: 无法在独立模式下安装时设置 _INSTANCES 
ORA-12810: PARALLEL_MAX_SERVERS 必须小于或等于 
ORA-12812: 仅可以指定一个 PARALLEL 或 NOPARALLEL 子句 
ORA-12813: PARALLEL 或 DEGREE 的值必须大于 0 
ORA-12814: 只能指定一个 CACHE 或 NOCACHE 子句 
ORA-12815: INSTANCES 的值必须大于 0 
ORA-12816: 并行创建索引快速路径操作 
ORA-12817: 必须启用并行查询选项 
ORA-12818: PARALLEL 子句中的选项无效 
ORA-12819: PARALLEL 子句中缺少选项 
ORA-12820: DEGREE 的值无效 
ORA-12821: INSTANCES 的值无效 
ORA-12822: PARALLEL 子句中的选项重复 
ORA-12823: 不可以在此处指定默认并行化程度 
ORA-12824: 不可以在此处指定 INSTANCES DEFAULT 
ORA-12825: 必须在此处指定明确的并行化程度 
ORA-12826: 挂起的并行查询服务器已停止 
ORA-12827: 可用并行查询从属项目不足 
ORA-12828: 无法启动远程站点的并行事务处理 
ORA-12829: 死锁 - 由 siblings 占用的 itls 位于块 , 文件 中 
ORA-12831: 在执行具有 APPEND 提示的 INSERT 之后必须 COMMIT 或 ROLLBACK 
ORA-12832: 无法分配所有指定例程中的从属项目 
ORA-12833: 协调程序例程不是 parallel_instance_group 的成员 
ORA-12834: 例程组名''过长，必须少于 个字符 
ORA-12835: GLOBAL_VIEW_ADMIN_GROUP 中没有活动的例程 
ORA-12836: 控制延迟的索引维护事件 
ORA-12837: 延迟的索引维护调试事件 
ORA-12838: 无法在并行模式下修改之后读/修改对象 
ORA-12839: 无法在修改之后在并行模式下修改对象 
ORA-12840: 在并行/插入直接加载 txn 之后无法访问远程表 
ORA-12841: 无法改变事务处理中的会话并行 DML 状态 
ORA-12842: 在并行执行过程中方案发生改变 
ORA-12843: 对表的 pdml 锁定不再完好 
ORA-12900: 必须为本地管理的数据库指定一个默认的临时表空间 
ORA-12901: 默认的临时表空间必须属 TEMPORARY 类型 
ORA-12902: 默认的临时表空间必须属 SYSTEM 或 TEMPORARY 类型 
ORA-12903: 默认的临时表空间必须是 ONLINE 表空间 
ORA-12904: 默认的临时表空间不能更改为 PERMANENT 类型 
ORA-12905: 默认的临时表空间不能脱机 
ORA-12906: 不能删除默认的临时表空间 
ORA-12907: 表空间 已经是默认的临时表空间 
ORA-12908: 在创建数据库时, 不能指定 SYSTEM 为默认的临时表空间 
ORA-12909: 需要 TEMPORARY 关键字 
ORA-12910: 无法将临时表空间指定为默认表空间 
ORA-12911: 永久表空间不能是临时表空间 
ORA-12912: 字典托管表空间指定为临时表空间 
ORA-12913: 无法创建字典管理的表空间 
ORA-12914: 无法将表空间移植到字典管理的类型中 
ORA-12915: 无法将字典管理的表空间变更为可读写 
ORA-12920: 数据库已经处于强制记录模式 
ORA-12921: 数据库未处于强制记录模式 
ORA-12922: 并行 ALTER DATABASE [NO] FORCE LOGGING 命令正在运行 
ORA-12923: 表空间 处于强制记录模式 
ORA-12924: 表空间 已经处于强制记录模式 
ORA-12925: 表空间 未处于强制记录模式 
ORA-12926: FORCE LOGGING 选项已指定 
ORA-12980: 检查点选项不允许 SET UNUSED 
ORA-12981: 无法从对象类型表中删除列 
ORA-12982: 无法从嵌套的表中删除列 
ORA-12983: 无法删除表的全部列 
ORA-12984: 无法删除分区列 
ORA-12985: 表空间 '' 为只读，无法删除列 
ORA-12986: 列处于部分删除状态。提交 ALTER TABLE DROP COLUMNS CONTINUE 
ORA-12987: 无法与其它操作合并删除列 
ORA-12988: 无法删除属于 SYS 的表中的列 
ORA-12989: 检查点间隔的无效值 
ORA-12990: 指定的选项重复 
ORA-12991: 引用的列处于多列约束条件 
ORA-12992: 无法删除父项关键字列 
ORA-12993: 表空间 '' 脱机，无法删除列 
ORA-12994: 语句中删除列选项仅允许一次 
ORA-12995: 没有列处于部分删除状态 
ORA-12996: 无法删除系统生成的虚拟列 
ORA-12997: 无法从索引组织的表中删除主键 
ORA-13000: 维数超出范围 
ORA-13001: 维数不匹配错误 
ORA-13002: 指定的层次超出范围 
ORA-13003: 维数的指定范围无效 
ORA-13004: 指定的缓冲区大小无效 
ORA-13005: 递归 HHCODE 函数错误 
ORA-13006: 指定的单元格数无效 
ORA-13007: 检测到无效的 HEX 字符 
ORA-13008: 指定的日期格式中具有无效的要素 
ORA-13009: 指定的日期字符串无效 
ORA-13010: 指定的参数个数无效 
ORA-13011: 值超出范围 
ORA-13012: 指定了无效的窗口类型 
ORA-13013: 指定的拓扑不是 INTERIOR 或 BOUNDARY 
ORA-13014: 拓扑标识超出指定的 1 到 8 范围 
ORA-13015: 窗口定义无效 
ORA-13016: 分区定义错误 
ORA-13017: 不可识别的行分区形状 
ORA-13018: 距离类型错误 
ORA-13019: 座标超出界限 
ORA-13020: 座标为 NULL 
ORA-13021: 元素不连续 
ORA-13022: 多边形自身交叉 
ORA-13023: 内部元素与外部元素交互作用 
ORA-13024: 多边形少于三段 
ORA-13025: 多边形没有关闭 
ORA-13026: 元素 .. 的元素类型未知 
ORA-13027: 无法从 读取维定义 
ORA-13028: SDO_GEOMETRY 对象中的 Gtype 无效 
ORA-13029: SDO_GEOMETRY 对象中的 SRID 无效 
ORA-13030: SDO_GEOMETRY 对象的维无效 
ORA-13031: SDO_GEOMETRY 对象中用于点对象的 Gtype 无效 
ORA-13032: NULL SDO_GEOMETRY 对象无效 
ORA-13033: SDO_GEOMETRY 对象中位于 SDO_ELEM_INFO_ARRAY 中的数据无效 
ORA-13034: SDO_GEOMETRY 对象中位于 SDO_ORDINATE_ARRAY 中的数据无效 
ORA-13035: SDO_GEOMETRY 对象中的数据 (测量数据中的弧) 无效 
ORA-13036: 对于点数据, 不支持操作 [] 
ORA-13037: 两个几何对象的 SRID 不匹配 
ORA-13039: 无法更新元素 .. 的空间索引 
ORA-13040: 无法细分铺砌 
ORA-13041: 无法比较铺砌与元素 .. 
ORA-13042: SDO_LEVEL 和 SDO_NUMTILES 的组合无效 
ORA-13043: 无法从 <layer>_SDOLAYER 表读取元数据 
ORA-13044: 指定的铺砌大小超出最大分辨率 
ORA-13045: 无效的兼容标志 
ORA-13046: 参数个数无效 
ORA-13047: 无法从表 <层>_SDOLAYER 确定纵座标数 
ORA-13048: 递归 SQL 取数错误 
ORA-13049: 无法从表 <layer>_SDODIM 确定容限值 
ORA-13050: 无法构造空间对象 
ORA-13051: 无法初始化空间对象 
ORA-13052: 不受支持的几何 . 的几何类型 
ORA-13053: 超出参数列表中的最大几何元素数 
ORA-13054: 递归 SQL 语法分析错误 
ORA-13055: 指定表中不存在 Oracle 对象 
ORA-13108: 未找到空间表 
ORA-13109: 存在空间表 
ORA-13110: 空间表 未分区 
ORA-13111: 空间表 没有定义的分区关键字 
ORA-13112: 无效的计数模式 
ORA-13113: Oracle 表 不存在 
ORA-13114: 未找到表空间 
ORA-13115: 已分配表空间 
ORA-13116: 表空间 未指定到表 
ORA-13117: 未找到分区 
ORA-13119: 源和目标表空间相同 
ORA-13121: 无法创建子分区 
ORA-13122: 未找到子分区 
ORA-13123: 已经定义列 
ORA-13124: 无法确定列 的列标识 
ORA-13125: 已经设置分区关键字 
ORA-13126: 无法确定空间表 的分类 
ORA-13127: 无法生成目标分区 
ORA-13128: 当前铺砌层超出用户指定的铺砌层 
ORA-13129: 未找到 HHCODE 列 
ORA-13135: 无法更改空间表 
ORA-13136: 生成了空的公用代码 
ORA-13137: 无法生成表空间序号 
ORA-13138: 无法确定对象 的名称 
ORA-13139: 无法获得 的列定义 
ORA-13140: 无效的目标类型 
ORA-13141: 无效的 RANGE 窗口定义 
ORA-13142: 无效的 PROXIMITY 窗口定义 
ORA-13143: 无效的 POLYGON 窗口定义 
ORA-13144: 未找到目标表 
ORA-13145: 无法生成范围列表 
ORA-13146: 无法找到表替代变量 
ORA-13147: 无法生成 MBR 
ORA-13148: 无法生成 SQL 过滤器 
ORA-13149: 无法生成空间表 的下一序号 
ORA-13150: 无法插入例外记录 
ORA-13151: 无法删除异常事件记录 
ORA-13152: 无效的 HHCODE 类型 
ORA-13153: 指定的高水印无效 
ORA-13154: 指定的精确度无效 
ORA-13155: 指定的维数无效 
ORA-13156: 要注册的表 . 非空 
ORA-13157: Oracle 错误 ORA 出现在 时 
ORA-13158: Oracle 对象 不存在 
ORA-13159: Oracle 表 已经存在 
ORA-13181: 无法确定列 _SDOINDEX.SDO_CODE 的长度 
ORA-13182: 无法读取元素 .. 
ORA-13183: 不受支持的几何 . 的几何类型 
ORA-13184: 无法初始化嵌套程序包 
ORA-13185: 无法生成初始 HHCODE 
ORA-13186: 固定铺砌大小嵌套失败 
ORA-13187: 细分失败 
ORA-13188: 单元格译码失败 
ORA-13189: 递归 SQL 语法分析失败 
ORA-13190: 递归 SQL 取数失败 
ORA-13191: 无法读取 SDO_ORDCNT 值 
ORA-13192: 无法读取元素行数 
ORA-13193: 无法分配几何空间 
ORA-13194: 无法解码超单元格 
ORA-13195: 无法生成最大的铺砌值 
ORA-13196: 无法计算元素 .. 的超单元格 
ORA-13197: 元素 .. 超出范围 
ORA-13198: 空间插件错误: 
ORA-13199: 
ORA-13200: 空间索引建立中出现内部错误 [] 
ORA-13201: 在 CREATE INDEX 语句中提供的参数无效 
ORA-13202: 创建或插入 SDO_INDEX_METADATA 表失败 
ORA-13203: 无法读取 USER_SDO_GEOM_METADATA 表 
ORA-13204: 创建空间索引表失败 
ORA-13205: 对空间参数进行语法分析时出现内部错误 
ORA-13206: 创建空间索引时出现内部错误 [] 
ORA-13207: 运算符 [] 使用不正确 
ORA-13208: 对运算符 [] 求值时出现内部错误 
ORA-13209: 读取 SDO_INDEX_METADATA 表时出现内部错误 
ORA-13210: 将数据插入索引表时出错 
ORA-13211: 嵌装窗口对象失败 
ORA-13212: 无法与窗口对象比较铺砌 
ORA-13213: 为窗口对象生成空间索引失败 
ORA-13214: 无法为窗口对象计算超单元格 
ORA-13215: 窗口对象超出范围 
ORA-13216: 无法更新空间索引 
ORA-13217: ALTER INDEX 语句中提供的参数无效 
ORA-13218: 索引表达到 [] 索引所支持的最大值 
ORA-13219: 无法创建空间索引表 [] 
ORA-13220: 无法与几何比较铺砌 
ORA-13221: 几何对象中未知的几何类型 
ORA-13222: 无法为几何在中计算超单元格 
ORA-13223: SDO_GEOM_METADATA 表中有重复的项 
ORA-13224: 为空间索引指定的索引名太长 
ORA-13225: 为空间索引指定的索引表名太长 
ORA-13226: 在没有空间索引的情况下不支持此界面 
ORA-13227: 两个索引表的 SDO_LEVEL 值不一致 
ORA-13228: 由于无效的类型，空间索引创建失败 
ORA-13230: 在创建 R-tree 期间无法创建临时表 [] 
ORA-13231: 在创建 R-tree 期间无法创建索引表 [] 
ORA-13232: 在创建 R-tree 期间无法分配内存 
ORA-13233: 无法创建 R-tree 的序列号 [] 
ORA-13234: 无法访问 R-tree-index 表 [] 
ORA-13236: R-tree 处理中的内部错误: [] 
ORA-13237: 在 R-tree 并发更新期间的内部错误: [] 
ORA-13239: 在 n-d R-tree 创建期间未指定 sdo_dimensionality 
ORA-13240: 指定的维度大于查询 mbr 的维度 
ORA-13241: 指定的维度与数据的维度不匹配 
ORA-13242: 无法读取 n-d R-tree 的容限值 
ORA-13243: n-d R-tree 不支持指定的操作符: [] 
ORA-13249: 
ORA-13250: 权限不足，无法修改元数据表项 
ORA-13251: 元数据表中有重复的项 
ORA-13260: 层次表 不存在 
ORA-13261: 几何表 不存在 
ORA-13262: 几何列 没有存在于表 中 
ORA-13263: 列 (在表 中) 不是 SDO_GEOMETRY 类型 
ORA-13264: 几何标识符列 没有存在于表 中 
ORA-13265: 几何标识符列 (在表 中) 不是 NUMBER 类型 
ORA-13266: 插入数据到表 时出错 
ORA-13267: 从层次表 读取数据出错 
ORA-13268: 从 USER_SDO_GEOM_METADATA 获取维数出错 
ORA-13269: 处理几何表时遇到内部错误 [] 
ORA-13270: OCI 错误
 ORA-13271: 给几何对象分配内存时出错 
ORA-13272: 几何对象 (在表 中) 无效 
ORA-13273: 维元数据表 不存在 
ORA-13274: 用不兼容的 SRID 调用了运算符 
ORA-13275: 在不受支持的类型上创建空间索引失败 
ORA-13276: 坐标转换中的内部错误 [] 
ORA-13278: 把 SRID 转换到本地格式中出现故障 
ORA-13281: 检索 WKT 的 sql 语句在执行中出现故障 
ORA-13282: 坐标转换的初始化出现故障 
ORA-13283: 无法获得新的位置转换的几何对象 
ORA-13284: 无法拷贝位置转换的几何对象 
ORA-13285: 几何坐标转换错误 
ORA-13287: 无法转换未知的 gtype 
ORA-13288: 点坐标转换错误 
ORA-13290: 不支持指定的单位 
ORA-13291: 在指定单位和标准单位之间转换时出错 
ORA-13292: ARC_TOLERANCE 的说明不正确 
ORA-13293: 不能为没有测量参照 SRID 的几何对象指定单位 
ORA-13294: 无法转换包含圆弧的几何结构 
ORA-13295: 几何对象位于不同的坐标系统中 
ORA-13296: 坐标系统的说明不正确 
ORA-13300: 单点转换错误 
ORA-13303: 无法从表中检索几何对象 
ORA-13304: 无法在表中插入转换的几何对象 
ORA-13330: 无效的 MASK 
ORA-13331: LRS 段无效 
ORA-13332: LRS 点无效 
ORA-13333: LRS 度量无效 
ORA-13334: 未连接 LRS 段 
ORA-13335: 未定义 LRS 度量信息 
ORA-13336: 无法将标准维信息/几何对象转换为 LRS 维/几何对象 
ORA-13337: 连接 LRS 多边形失败 
ORA-13338: 翻转 LRS 多边形/收集几何对象失败 
ORA-13339: LRS 多边形剪贴操作涉及到多个环 
ORA-13340: 几何点的坐标多于一个 
ORA-13341: 几何线的坐标少于两个 
ORA-13342: 几何弧的坐标少于三个 
ORA-13343: 几何多边形的坐标少于四个 
ORA-13344: 几何弧多边形的坐标少于五个 
ORA-13345: 几何复合多边形的坐标少于五个 
ORA-13346: 定义弧的坐标在同一直线上 
ORA-13347: 定义弧的坐标未分开 
ORA-13348: 多边形边界未封闭 
ORA-13349: 多边形边界自身交叉 
ORA-13350: 复杂多边形的两个或多个环相接 
ORA-13351: 复杂多边形的两个或多个环重叠 
ORA-13352: 坐标未描述出一个圆 
ORA-13353: ELEM_INFO_ARRAY 未按三的倍数组合 
ORA-13354: ELEM_INFO_ARRAY 中出现不正确的偏移量 
ORA-13355: SDO_ORDINATE_ARRAY 没有按指定的维数组合 
ORA-13356: 几何中的相邻点多余 
ORA-13357: 扩充区块类型未包含两点 
ORA-13358: 圆类型未包含三点 
ORA-13359: 扩充区块没有区域 
ORA-13360: 复合类型中无效的子类型 
ORA-13361: 复合 ETYPE 中没有足够的子元素 
ORA-13362: 复合多边形中的子元素未连接 
ORA-13363: 几何中没有有效的 ETYPE 
ORA-13364: 层维度与几何对象维数不匹配 
ORA-13365: 层 SRID 与几何对象 SRID 不匹配 
ORA-13366: 内环和外环的组合无效 
ORA-13367: 内环/外环的方向错误 
ORA-13368: 简单多边形类型有多个外环 
ORA-13369: 4 位数字的 etype 值无效 
ORA-13370: 应用 3D LRS 函数失败 
ORA-13371: 度量维的位置无效 
ORA-13372: 修改具有空间索引的表的元数据失败 
ORA-13373: 测量数据不支持类型为 Extent 的元素 
ORA-13374: 测量数据不支持 SDO_MBR 
ORA-13375: 层属于 [] 类型, 而插入的几何对象的类型为 [] 
ORA-13376: 为 layer_gtype 参数指定的类型名无效 
ORA-13377: 元素组合的方向无效 
ORA-13378: 所要抽取的元素索引无效 
ORA-13379: 所要抽取的子元素索引无效 
ORA-13400: Oracle GeoImage 内部错误， 参数: []，[]， []， []， []
 Copyright ©2010 lyt. All Rights Reserved.







study
ORA-01139
ORA-01139: RESETLOGS option only valid after an incomplete database recovery
介绍一个意外情况，如果上面的方法不成功，数据库还是不能open，采用recover，restore 都不成功，说明logfile可能
已经损坏，数据库打开需要做一致性检查，所以不能正常打开。因为数据库未作过备份，为了尽可能地减少损失，采用打
开数据库，然后立刻导出数据的方法。
oracle有一个不推荐的方法，可以使数据库在不进行一致性检查的方式下打开数据库。
做法：
1。为保险起见，将数据库的系统表空间，数据文件，控制文件均做一次备份：copy。
2。在初始化配置文件中（init.ora）加上：
_allow_resetlogs_corruption=true
_corrupted_rollback_segments= (将所有rollback_segments=(...)的内容加到这里）
将rollback_segments=(...)前加上#
3。 startup mount
recover database until cancel；
cancel
alter database open resetlogs;
此时数据库已经可以打开了，请立刻将数据export出来，然后重新安装oracle，重新建立database，再将数据 import。
注意：这种方法属于数据库的不完全恢复，最后提交的sql可能会丢失，毕竟能够尽可能地减少损失，可以试试。
_allow_resetlogs_corruption=true   隐含参数据设置
 Copyright ©2010 lyt. All Rights Reserved.


 