 
查询一个表中的列名desc tablename;
查询所有的表名select table_name from tabs;

R[un]:显示并运行上一条命令
L[ist] :显示上一条命令
/ :运行上一条命令
spool :将查询出的输出结果存到指定的文件(用spool off关)
varable :定义变量
show spool :显示输出是否写入文件
show user :显示当前用户
show all :显示所有的环境变量
show errors :显示所有的错误
help index :
help variable :
host :用于执行操作系统命令 可用$+os命令
exit/quit :退出\断开连接
@ :文件路径
@@ :文件路径
column :规定显示属性
set pause[on/off] :是否滚动显示
set pagesize :默认14
set linesize :默认80
set feedback[on.off] :是否显示影响行数
set longback:设置long值,显示更多数据
clear screen:清楚缓存区和屏幕信息
truncate table :只删除数据
desc :显示表结构
冷备份
shutdown immediate
热备份：
查看归档方式：
archive log list;
改变归档方式：
alter system set log_archive_start=true scope=spfile
startup mount



1.学号(自动编号) 姓名 性别 年龄
0001 xw 男 18
0002 mc 女 16
0003 ww 男 21
0004 xw 男 18
请写出实现如下功能的SQL语句:
删除除了学号（自动编号）字段以外，其它字段都相同的冗余记录！
DELETE FROM table1
WHERE (学号 NOT IN
(SELECT MAX(学号) AS xh
FROM TABLE1
GROUP BY 姓名, 性别, 年龄))


2.数据库有3个表 teacher表 student表 tea_stu关系表 teacher表 teaID name age student表 stuID name age teacher_student表 teaID stuID 要求用一条sql查询出这样的结果: 1.显示的字段要有老师id age 每个老师所带的学生人数 2.只列出老师age为40以下 学生age为12以上的记录。
3.sql面试题一条语句查询每个部门共有多少人
前提:a 部门表 b 员工表 
a表字段( 
id --部门编号 
departmentName-部门名称 
) 
b表字段( 
id--部门编号 
employee- 员工名称 
) 

问题:如何一条sql语句查询出每个部门共有多少人
select count(b.id)as employeecount,a.departmentName from a left join b on a.id=b.id group by b.id,a.departmentName
4.有3张表，Student表、SC表和Course表 
Student表:学号（Sno）、姓名（Sname）、性别（Ssex）、年龄（Sage）和系名（Sdept） 
Course表:课程号（Cno）、课程名（Cname）和学分（Ccredit）； 
SC表：学号（Sno）、课程号（Cno）和成绩（Grade） 
请使用SQL语句查询学生姓名及其课程总学分 
（注：如果课程不及格，那么此课程学分为0）
方法1：select Sname,sum(Ccredit) as totalCredit from Student,Course,SC where Grade>=60 and Student.Sno=SC.Sno and Course.Cno=SC.Cno group by Sname 
方法2：对xyphoenix的修改 
select sname,sum(case when sc.grade<60 then 0 else course.Ccredit end) as totalCredit from Student,sc,course where sc.sno=student.sno and sc.cno=course.cno group by sname 
方法3：对napolun180410的修改 
select Sname,SUM(case when Grade<60 then 0 else Ccredit end) as totalGrade FROM SC JOIN Student ON(Student.sno = SC.sno) JOIN Course ON(SC.Cno = Course.Cno) GROUP BY Student.Sname;
 
 
子查询中的in和exsists什么时候使用?
答:    关于EXISTS与IN的区别：
EXISTS检查是否有结果，判断是否有记录，返回的是一个布尔型（TRUE/FALSE）。
IN是对结果值进行比较，判断一个字段是否存在于几个值的范围中，所以 EXISTS 比 IN 快。
主要区别是:
exists主要用于片面的,有满足一个条件的即可,
in主要用于具体的集合操作,有多少满足条件.
exists是判断是否存在这样的记录，
In是判断某个字段是否在指定的某个范围内。
exists快一些吧 。
in适合内外表都很大的情况，exists适合外表结果集很小的情况。
 
EXISTS与IN的区别：
IN:    确定给定的值是否与子查询或列表中的值相匹配。
EXISTS:    指定一个子查询，检测行的存在。
存储过程在软件开发中有什么样的优势和劣势，有什么样的缺点。
答：存储过程的优点：
（1）       允许模块化程序设计，以后可以重复调用;可以由专人来完成，并可独立于程序源代码而单独修改。这样一个项目在需求分析、界面设计以及数据库设计完了以后，就可以开始写存储过程了，同一时间数据访问层也可以开始写了。没有必要等详细设计说明完成了在编码的时候才开始写SQL语句。
（2）       执行更快
存储过程都是预编译命令，执行起来比SQL语句更快。
（3）       减少网络流量
（4）       可作为安全机制，能够屏蔽数据库，用户并不知道数据库的真实结构。
存储过程的缺点
　　　最大的缺点就是更换数据库的时候，比如SQL＿Server数据库换成Oracle数据库时SQL＿Server数据库的存储过程在Oracle当中完全不能用，只能重新用Oracle的命令来写存储过程。
如果你的项目在开发时使用了存储过程，在改换数据库时，会发生什么样的问题，如何解决？
答：更换数据库的时候，比如SQL＿Server数据库换成Oracle数据库时SQL＿Server数据库的存储过程在Oracle当中完全不能用，只能重新用Oracle的命令来写存储过程。
　　　对于这个问题，解决的办法是：采用统一的数据库建模工具，比如（　），所有的数据库设计全部在这个统一个数据库建模工具里进行，存储过程也可以在这里完成。最后在根据需要转设成具体的某一种数据库，如果需要SQL＿Server就转变成SQL＿Server数据库，如果需要Oracle就转变成Oracle数据库。
存储过程的输出参数有几种形式，分别介绍一下，　返回值的类型有没有什么限制？
答：在SQL＿Server中有四种形式：
（1）、以OUTPUT参数形式返回数据，返回值的类型限制为：整形值、字符值也可以是游标变量，这种形式，可以一次返回多个值。
（2）、以Return的形式返回值，返回值的类型限制为：整形值，　以表明过程的执行状态。
（3）、返回SELECT语句的结果集。
（4）、可以返回能从存储过程外引用的全局游标。
　　　　在Oracle中有三种形式：
　　　　　　　　（1）、以OUT参数形式返回数据，返回值的类型限制为：不可以是大数据类型如：LOB、CLOB、BFILE等。
　　　　　　　　（2）、以IN OUT形式返回数据，返回值的类型限制为：也不可以是大数据类型。
（3）、返回SELECT语句的结果集。
　　　　在Oracle中存储过程没有Return的返回值，只有方法Function才有返回值
如果两个不同的存储过程在一个方中被同是调用，当其中任一个发生异常时，要求同时回滚两个存储过程的操作，怎么样处理？
答：可以创建另个一个存储过程，在这个存储中，创建一个自组事务，在这个自组事务中分别去调用那两个存储过程。语法如下：
    create procedure CallTwoProc
    as
    begin transaction
          execute 第一个存储过程
          execute 第二个存储过程
    commit transaction
    go
请谈一谈视图的优点（创建视图的必要性）。基于视图的增删改会带来什么样的问题，如何解决样的的问题？
答：视图的优点：
       (1)、可以筛选表中的行。
       (2)、可以将多个物理数据表抽象为一个逻辑表，有利于跨库操作。
       (3)、防止未经许可的用户访问敏感数据。
       (4)、降低数据库的复杂程度。
       (5)、视图是一种抽象表，它不占用存储空间。
    基于视图的增删改会带来两个的问题：
        (1)、INSERT、UPDATE和DELETE语句都必须要满足视图的条件，即视图要能看得到的才能INSERT、UPDATE和DELETE。通过视图的删除数据，要慎用，如果视图看不到的，无法删除。
解决办法：给视图加上with check option约束之后，基于视图的更改，凡是不符合视图约束(where……)的修改、插入、删除时会报错，用以限制对视图的修改。
         (2)、当一个视图是基于多个基表建立的，在视图上修改数据时，只能INSERT或UPDATE基于一个基表的字段的值，无法同时修改两个或以上的基表的字段。DELETE不能运行，因为DELETE语句仅在视图的FROM子句中只包含一个表时才可以引用更新视图。
           解决办法：建立INSTEAD OF触发器，把对视图的INSERT、UPDATE、DELETE操作转换为分别对几个基表的INSERT、UPDATE、DELETE操作，分作几步进行。这样对视图的INSERT、UPDATE、DELETE操作就有效了。
索引有什么样的优点，也有什么样的缺点，我们在运用索引的时候，是显示运用的吗，那是怎么样应用的呢，请举例说明。
答：索引的优点：可以加快我们的查询速度。
    索引的缺点：
(1)、当我们INSERT、UPDATE、DELETE时 ，数据库系统总是要去 更新每一个索引，因此而浪费很多时间。所以在基于事务的系统中，应尽量少建立索引。
(2)、带索引的给在数据库中会占据更多的存储空间。
    索引并不显示使用，而是在执行SQL语句时，当中含有WHERE、ORDER BY、GROUP BY、HAVING等了句时，即凡是有对数据进行搜索和排序的语句，查询优化器组件会找出查询效率最高的办法，而查询优化器就会选择最优的索引进行工作。
如果一个表其中有三个字段很常用，它们是A，B，C三个字段　，其中B字段更常用，那么这时我们应该怎么样创建索引。
答：创建一个组合索引，其中包括A、B、C三个字段 ，但一定要把B字段放在最前面。
因为B字段最常用，它的唯一性应该是最高的。
如果一个表有10万条记录，其中有10个它段非常常用，我们应该怎么样他建索引。
    答：创建一个组合索引，其中只包括非常常用的10个字段 ，排列的顺序一定是按唯一性的高低进行排列，唯一性最高的字段放在最前面，唯一性最低的放在最后面。
触发器会产生递归调用吗，请举例说明，像这种情况，我们应该怎么样避免呢？
    答：触发器会产生递归调用。有两种情况
         第一种：直接递归 即触发器被激发并执行一个操作，而该操作又使同一个触发器被激发。
         第二种：间接递归 即触发器被激发并执行一个操作，而该操作又使另一个触发器被激发。第二个触发器又使得第一个触发器的原始表得到更新，从而再一次引发第一个触发器。
         避免的办法有：
              (1)、在编写触发器里，人为的注意到这一点。
              (2)、防止直接递归：alter database pubs set RECURSIVE_TRIGGERS OFF
                  防止间接递归：请将 nested triggers 服务器选项设置为 0。
在数据查询中，我们需要把两个或者多个表作横方向联接，用什么命令？
　　答：用联接来解决这个问题join…..on
请问联接有多少种类，分别是哪几种？
　　答：有三种，他们是左联接 left join ….on,右联接　right join…..on, 内联接inner join……on或者join……on。
在联接中，用什么来指定联接的条件？
　　答：用on
在联接查询查询中，有没有规定在所查询的两个表的字段中一定要有主鍵字段？
答：没有这种说法，不一定必须查询主鍵，正确的说法是：典型的联接是指定一个表的外鍵以及在另一个表上的关联鍵。在数据查询中，我们需要把两个或者多个表作纵方向联接，用什么命令？
　　　答：使用Union联合命令。
在使用Union联合命令时，我们应注意些什么？
　　　答：所联合的几个查询，字段名可以不相同，但是字段类型、字段数都必须要相同。
请说一说Union和Union　All这两个命令的区别？
　　　答：Union命令得到的结果会去掉重复项，作了一个distinct操作。
　　　　　Union　All命令不会去掉重复项。
 
存储过程和函数的区别
  存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。
事务是什么？ 
事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务： 

原子性 
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。 
一致性 
事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。 
隔离性 
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。 
持久性 
事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。 


游标的作用？如何知道游标已经到了最后？
   游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。
触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别。
    事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。 
语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。
用户权限类型及作用：
①对象权限 作用：决定用户对数据库对象所执行的操作，包括用户对数据库中的表、视图、列或存储过程等对象的操作权限
②语句权限 作用：决定用户能否操作数据库和创建数据库对象
 ③隐含权限 作用：控制那些只能由预定义系统角色的成员或数据库对象所有者执行的活动。
 
 