第一节 完整性约束条件

完整性检查是围绕完整性约束条件进行的，因此完整性约束条件是完整性控制机制的核心。
　　完整性约束条件作用的对象可以是关系、元组、列三种。其中列约束主要是列的类型、取值范围、精度、排序等的约束条件。元组的约束是元组中各个字段间的联系的约束。关系的约束是若干元组间、关系集合上以及关系之间的联系的约束。
　　 
　　完整性约束条件涉及的这三类对象，其状态可以是静态的，也可以是动态的。所谓静态约束是指数据库每一确定状态时的数据对象所应满足的约束条件，它是反映数据库状态合理性的约束，这是最重要的一类完整性约束。
　　动态约束是指数据库从一种状态转变为另一种状态时，新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束。
　　综合上述两个方面，可以将完整性约束条件分为六类，
　　一、静态列级约束
　　二、静态元组约束
　　三、静态关系约束
　　四、动态列级约束
　　五、动态元组约束
　　六、动态关系约束


第二节 完整性控制

DBMS的完整性控制机制应具有三个方面的功能：
　　· 定义功能，提供定义完整性约束条件的机制。
　　· 检查功能，检查用户发出的操作请求是否违背了完整性约束条件。
　　· 如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性。
　　完整性约束条件包括有六大类，约束条件可能非常简单，也可能极为复杂。一个完善的完整性控制机制应该允许用户定义所有这六类完整性约束条件。
　　检查是否违背完整性约束的时机通常是在一条语句执行完后立即检查，称这类约束为立即执行约束（Immediate Constraints）。有时完整性检查需要延迟到整个事务执行结束后再进行，检查正确方可提交，称这类约束为延迟执行约束（Deferred Constraints）。例如银行数据库中“借贷总金额应平衡”的约束就应该是延迟执行的约束，从账号A转一笔钱到账号B为一个事务，从账号A转出去钱后账就不平了，必须等转入账号B后账才能重新平衡，这时才能进行完整性检查。
　　如果发现用户操作请求违背了完整性约束条件，系统将拒绝该操作，但对于延迟执行的约束，系统将拒绝整个事务，把数据库恢复到该事务执行前的状态。
　　 
　　一条完整性规则可以用一个五元组(D，O，A，C，P)来表示，其中：
　　· D（Data） 约束作用的数据对象；
　　· O（Operation） 触发完整性检查的数据库操作，即当用户发出什么操作请求时需要检查该完整性规则，是立即检查还是延迟检查；
　　· A（Assertion） 数据对象必须满足的断言或语义约束，这是规则的主体；
　　· C（Condition） 选择A作用的数据对象值的谓词；
　　· P（Procedure） 违反完整性规则时触发的过程。
　　例如，在“学号不能为空”的约束中
　　D 约束作用的对象为Sno属性
　　O 插入或修改Student 元组时
　　A Sno不能为空
　　C 无（A可作用于所有记录的Sno属性）
　　P 拒绝执行该操作
　　又如，在“教授工资不得低于1000元”的约束中
　　D 约束作用的对象为工资Sal属性
　　O 插入或修改职工元组时
　　A Sal不能小于1000
　　C 职称=′教授′（A仅作用于职称=′教授′的记录）
　　P 拒绝执行该操作
　　在关系系统中，最重要的完整性约束是实体完整性和参照完整性，其他完整性约束条件则可以归入用户定义的完整性。
　　目前许多关系数据库管理系统都提供了定义和检查实体完整性、参照完整性和用户定义的完整性的功能。对于违反实体完整性和用户定义的完整性的操作一般都采用拒绝执行的方式进行处理。而对于违反参照完整性的操作，并不都是简单地拒绝执行，有时要根据应用语义执行一些附加的操作，以保证数据库的正确性。
　　在2.3节中已讨论了关系系统中的实体完整性、参照完整性和用户定义的完整性的含义，下面详细讨论实现参照完整性要考虑的几个问题。
　　1. 外码能否接受空值问题
　　例如，职工-部门数据库包含职工表EMP和部门表DEPT，其中DEPT关系的主码为部门号Deptno，EMP关系的主码为职工号Empno，外码为部门号Deptno，称DEPT为被参照关系或目标关系，EMP为参照关系。
　　EMP中，某一元组的Deptno列若为空值，表示这个职工尚未分配到任何具体的部门工作。这和应用环境的语义是相符的，因此EMP的Deptno列可以取空值。但在学生－选课数据库中，Student关系为被参照关系，其主码为Sno。SC为参照关系，外码为Sno。若SC的Sno为空值，则表明尚不存在的某个学生，或者某个不知学号的学生，选修了某门课程，其成绩记录在Grade列中。这与学校的应用环境是不相符的，因此SC的Sno列不能取空值。
　　因此在实现参照完整性时，系统除了应该提供定义外码的机制，还应提供定义外码列是否允许空值的机制。
　　2. 在被参照关系中删除元组的问题
　　例如要删除Student关系中Sno=95001的元组，而SC关系中又有4个元组的Sno都等于95001，一般地，当删除被参照关系的某个元组，而参照关系存在若干元组，其外码值与被参照关系删除元组的主码值相同，这时可有三种不同的策略：
　　（1）级联删除（CASCADES）
　　将参照关系中所有外码值与被参照关系中要删除元组主码值相同的元组一起删除。例如将上面SC关系中4个Sno=95001的元组一起删除。如果参照关系同时又是另一个关系的被参照关系，则这种删除操作会继续级联下去。
　　（2）受限删除（RESTRICTED）
　　仅当参照关系中没有任何元组的外码值与被参照关系中要删除元组的主码值相同时，系统才执行删除操作，否则拒绝此删除操作。例如对于上面的情况，系统将拒绝删除Student关系中Sno=95001的元组。
　　（3）置空值删除（NULLIFIES）
　　删除被参照关系的元组，并将参照关系中相应元组的外码值置空值。例如将上面SC关系中所有Sno=950001的元组的Sno值置为空值。
　　这三种处理方法，哪一种是正确的呢？这要依应用环境的语义来定。在学生-选课数据库中，显然第一种方法是对的。因为当一个学生毕业或退学后，他的个人记录从Student表中删除了，他的选课记录也应随之从SC表中删除。
　　3. 在参照关系中插入元组时的问题
　　例如向SC关系插入（99001，1，90）元组，而Student关系中尚没有Sno=99001的学生，一般地，当参照关系插入某个元组，而被参照关系不存在相应的元组，其主码值与参照关系插入元组的外码值相同，这时可有以下策略：
　　（1）受限插入
　　仅当被参照关系中存在相应的元组，其主码值与参照关系插入元组的外码值相同时，系统才执行插入操作，否则拒绝此操作。例如对于上面的情况，系统将拒绝向SC关系插入（99001，1，90）元组。
　　（2）递归插入
　　 
　　首先向被参照关系中插入相应的元组，其主码值等于参照关系插入元组的外码值，然后向参照关系插入元组。例如对于上面的情况，系统将首先向Student关系插入Sno=99001的元组，然后向SC关系插入（99001，1，90）元组。
　　4. 修改关系中主码的问题
　　（1）不允许修改主码
　　在有些RDBMS中，修改关系主码的操作是不允许的，例如不能用UPDATE语句将学号95001改为95102。如果需要修改主码值，只能先删除该元组，然后再把具有新主码值的元组插入到关系中。
　　（2）允许修改主码
　　在有些RDBMS中，允许修改关系主码，但必须保证主码的唯一性和非空，否则拒绝修改。
　　当修改的关系是被参照关系时，还必须检查参照关系，是否存在这样的元组，其外码值等于被参照关系要修改的主码值。例如要将Student关系中Sno=950001的Sno值改为960123，而SC关系中有4个元组的Sno=950001，这时与（上面第2点）在被参照关系中删除元组的的情况类似，可以有：级联修改、拒绝修改、置空值修改三种策略加以选择。
　　当修改的关系是参照关系时，还必须检查被参照关系，是否存在这样的元组，其主码值等于被参照关系要修改的外码值。例如要把SC关系中（95001，1，90）元组修改为（99001，1，90），而Student关系中尚没有Sno=99001的学生，这时与（上面第3点）在参照关系中插入元组时的情况类似，可以有：受限插入和递归插入两种策略加以选择。
　　从上面的讨论看到DBMS在实现参照完整性时，除了要提供定义主码、外码的机制外，还需要提供不同的策略供用户选择。选择哪种策略，都要根据应用环境的要求确定。
 Copyright ©2011 lyt. All Rights Reserved.


第三节 Oracle的完整性

上面介绍了完整性控制的一般方法，下面介绍Oracle的完整性控制策略。
　　一、Oracle中的实体完整性
　　Oracle在CREATE TABLE语句中提供了PRIMARY KEY子句，供用户在建表时指定关系的主码列。例如，在学生-选课数据库中，要定义Student表的Sno为主码，可使用如下语句：
　　 CREATE TABLE Student
　　 (Sno NUMBER(8)，
　　 Sname VARCHAR(20)，
　　 Sage NUMBER(20)，
　　 CONSTRAINT PK_SNO PRIMARY KEY (Sno))； 
　　其中，PRIMARY KEY(Sno)表示Sno是Student表的主码。PK_SNO是此主码约束名。
　　若要在SC表中定义(Sno， Cno)为主码，则用下面语句建立SC表：
　　 CREATE TABLE SC
　　 (Sno NUMBER(8)，
　　 Cno NUMBER(2)，
　　 Grade NUMBER(2)，
　　 CONSTRAINT PK_SC PRIMARY KEY (Sno，Cno) )；
　　用PRIMARY KEY语句定义了关系的主码后，每当用户程序对主码列进行更新操作时，系统自动进行完整性检查，凡操作使主码值为空值或使主码值在表中不唯一，系统拒绝此操作，从而保证了实体完整性。
　　二、Oracle中的参照完整性
　　Oracle的CREATE TABLE语句也可以定义参照完整性规则，即用FOREIGN KEY子句定义哪些列为外码列，用REFERENCES子句指明这些外码相应于哪个表的主码，用ON DELETE CASCADE子语指明在删除被参照关系的元组时，同时删除参照关系中相应的元组。
　　例如，使用如下SQL语句建立表EMP表：
　　 CREATE TABLE EMP
　　 (Empno NUMBER(4)，
　　 Ename VARCHAR(10)，
　　 Job VARCHAR2(9)，
　　 Mgr NUMBER(4)，
　　 Sal NUMBER(7，2)，
　　 Deptno NUMBER(2)，
　　 CONSTRAINT FK_DEPTNO
　　 FOREIGN KEY (Deptno)
　　 REFERENCES DEPT(Deptno) )；
　　则表明EMP是参照表，DEPT为其被参照表，EMP表中Deptno为外码，它相应于DEPT表中的主码Deptno。当删除或修改DEPT表中某个元组的主码时要检查EMP中是否有元组的DEPTNO值等于DEPT中要删除的元组的Deptno值，如没有，接受此操作；否则系统拒绝这一更新操作。
　　如果用如下SQL语句建立EMP表：
　　 CREATE TABLE EMP
　　 (Empno NUMBER(4)，
　　 Ename VARCHAR(10)，
　　 Job VARCHAR2(9)，
　　 Mgr NUMBER(4)，
　　 Sal NUMBER(7，2)，
　　 Deptno NUMBER(2)，
　　 CONSTRAINT FK_DEPTNO
　　 FOREIGN KEY (Deptno)
　　 REFERENCES DEPT(Deptno)
　　 ON DELETE CASCADE)；
　　当要修改DEPT表中的Deptno值时，先要检查EMP表中有无元组的Deptno值与之对应，若没有，系统接受这个修改操作，否则，系统拒绝此操作。
　　当要删除DEPT表中某个元组时，系统也要检查EMP表，若找到相应元组则将它们也随之删除。
　　三、Oracle中用户定义的完整性
　　除实体完整性和参照完整性外，应用系统中往往还需要定义与应用有关的完整性限制。例如：要求某一列的值不能取空值，要在表中是唯一的，要在某个取值范围中等。Oracle允许用户在建表时定义下列完整性约束：
　　· 列值非空（NOT NULL短语）
　　· 列值唯一（UNIQUE短语）
　　· 检查列值是否满足一个布尔表达式（CHECK短语）
 Copyright ©2011 lyt. All Rights Reserved.


 